Model
모델은 데이터의 구조를 잡아주고 정의된 구조를 기반으로 데이터베이스와 소통한다

데이터 구조
우리가 저장할 정보들의 형태이다 코스트랑에 들어갈만한 정보의 형태는? 우선 코스트랑에는 여러가지 메뉴가 있고 각각의 메뉴마다 음식으 이름 간단한 설명 그리고 가격이 있다
여기서 이름과 설명은 문자(str)의 형태로 저장하면 되고 가격은 숫자형태(int)로 저장하면 된다 이런식으로 각각의 데이터구조와 형식을 정하는것을 데이터 모델릴 (Data Modeling)이라 한다
쉽게 말해 데이터 모델링은 우리 서비스의 요구 사항에 맞게 데이터를 짜는 것이다

실재로 데이터를 저장하는 곳은? 데이터 베이스(Data Base)
대표적인 데이터베이스로는 MySQL, PostgreSQL, Oracle, MongoDB, SQLite 같은 것들이 있다 그리고 이러한 데이터 베이스에 데이터를
추가하거나 (Create) 조회하거나 (Read) 수정하거나 (Update) 지우거나 (Delete) 하는데 이러한 과정을 SQL 이라는 언어를 통해서 한다 
그런데 지금까지 파이썬 html css Django 까지 배우느냐 고생하는데 sql 까지 배우려면 막막하다! 그래서 장고에서는 파이썬을 이용해서 데이터베이스와 소통하게 해주는 도구가 있다
바로 ORM이다

ORM (Object-Relational Mapper)
원래 데이터베이스와 소통하기 위해서는 sql로 된 코드를 길게 써야하는데 이 ORM을 쓰면 파이썬을 이용해 데이터베이스와 소통할 수 있다 이게 어떻게 가능하냐?
장고에서는 Model애서 ORM을 제공한다 우리가 서비스의 요구 사항에 맞게 데이터 모델을 정의한 후 어떤 식으로 파이썬 코드를 쓰면 아 이 모델은 이런 형식으로 데이터를 정의하는구나 하고 장고에서 인식해서
그에 맞는 sql 코드를 자동으로 생성해서 실행하고 우리가 정의해준 형태에 맞게 데이터베이스에 저장된다 그리고 만약 이런 코드를 쓰면 적절한 sql 코드를 자동으로 생성한 다음 실행해서 원하는 데이터를 데이터베이스로부터 
읽어오게 된다 

Model 작성하기
이제 데이터를 웹페이지 파일 자체에 코딩해놓는게 아니라 모델을 이용해서 데이터베이스에 저장해 놓고 필요할 때 꺼내서 사용하자
일단 코스토랑은 음식에 대한 모델 객체가 필요하다 데이터 구조를 어떻게 잡아야할지 데이터 모델링부터 해보자 foods앱의 views.py를 가서 food_detail 함수를 보면 

def food_detail(request, food):
    context = dict() #빈 사전형 생성
    if food == 'chicken':
        context['name'] = '코딩에 빠진 닭'
        context['description'] = '주머니가 가벼운 당신의 마음까지 생각한 가격 !'
        context['price'] = 10000
        context['img_path'] = 'foods/images/chicken.jpg'
    else:
        raise Http404('이런 음식은 없습니다')
    return render(request, 'foods/detail.html', context = context)

하나의 메뉴는 이름과 설명 가격 그리고 이미지로 이루어져있다
그러면 이름과 설명 그리고 이미지 경로는 문자열로 저장하고 음식 가격은 숫자로 저장하면 되겠다
그럼 바로 모델을 작성해보자 foods 앱 안의 models.py 로 가자 모든 모델은 클래스로 구성된다 클래스를 쓰고 이름은 menu라고 하자 

class Menu(models.Model):

그리고 모델 클래스는 장고의 models.Model을 상속받아 구현한다
앞에서 배운 템플릿 상속이 기억나는가? 상속은 공통되는 부분을 모아 부모 객체로 만들고 자식 객체에서는 공통 기능은 부모객체로부터 상속 받아 사용하고 각각 달라지는 부분만 작성한다

맨 처음은 음식 이름을 저장할 구조를 만든다 각각의 데이터에 대한 형식을 필드라고 한다 음식에 대한 name 은 장고에서 제공하는 models를 이용해서 CharField 로 하면 된는데 이 CharField는 저장할 최대 길이를
필수 인수로 넘겨줘야한다 음식 이름 최대 길이를 50으로 하자

class Menu(models.Model):
    name = models.CharField(max_length=50)
  
이렇게 장고에서 제공하는 Field가 여러개가 있는데 지금 다 알아볼 수 없으니 나올때 마다 하나씩 알아보자 다음으로 음식 설명을 위해서 description 변수에 똑같이 CharField 를 만들어주는데 설명이 기니까 100자로 하자
그리고 가격은 숫자니까 IntegerField로 하자 이미지 경로는 문자열이므로 CharField를 쓰고 경로가 길어질 수 있으니 255로 하자

class Menu(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField(max_length=100)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)

그 다음 함수를 하나 정의해준다

class Menu(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField(max_length=100)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)
    
    def __str__(self):
        return self.name

이 __str__ 함수는 이 Menu 클래스는 하나의 문자열로 표현하는 것을 지정해주는 함수이다 print(Menu)를 썼을 떄 결과로 나오는 문자열을 넣어주는 것이다
그리고 여기 return 뒤에 결과로 돌려줄 문자를 적게 되는데 우리는 가각의 음식의 이름을 결과값으로 돌려주도록 하자
자 이렇게 하면 모델작성이 끝났다 생각보다 간단하져? 그리고 이렇게 모델을 새로 작성했거나 중간에 수정했다면 장고에게 사용하는 모델이 바뀌었다고 알려줘야한다
터미널에로 가서 현재 위치를 프로젝트 루트로 바꾼다 그리고 다음의 명령어를 쓴다

python3 manage.py makemigrations (나는 python3로)

콘솔에 다음과 같이 출력된다

Migrations for 'foods':
  foods/migrations/0001_initial.py
    - Create model Menu

모델이 만들어졌다 그 다음에 또 따라서 입력해보자

python3 manage.py migrate

그러면 우리가 만들어준 foods 앱과 더불어 장고에서 미리 만들어주는 여러 데이터 구조들이 함께 반영된다

------------------------------------------------------------------------------------------------------------------------------------
Django의 Model Field

Django Model은 대부분의 데이터를 저장할 수 있는 필드(Field)를 지원하는데 모든 필드에 사용할 수 있는 공통 옵션이 있고, 각각의 필드마다 가지고 있는 고유 옵션이 있습니다. 여기서는 자주 사용할 만한 몇 가지 필드와 옵션을 살펴보겠습니다.
필드(Field)

필드(Field)는 데이터 테이블에서의 열(column), 즉 데이터의 속성을 의미합니다.
CharField

class CharField(max_length=None)

제한된 길이의 문자열을 위한 필드입니다.

    max_length 필수 인수이며 입력할 최대 길이를 설정합니다.

IntegerField

class IntegerField()

정수 값을 위한 필드이며 -2147483648 부터 2147483647 범위를 지원합니다.
BooleanField

class BooleanField()

Boolean 값을 위한 필드 입니다.
DateField

class DateField(auto_now=False, auto_now_add=False)

DateField는 파이썬의 datetime.date 객체 형태로 표시되는 날짜 필드입니다.

    auto_now
      true로 설정되면 해당 객체가 변경(save) 될 때마다 자동으로 필드 값을 지금으로 수정합니다. '마지막 수정 시간' 같은 항목으로 사용하면 좋겠죠?

    auto_now_add
      모델이 처음 생성될 때 한 번, 자동으로 필드 값을 지금으로 설정합니다. '생성된 시간'을 저장하기 위해 많이 사용합니다.

DateTimeField

class DateTimeField(auto_now=False, auto_now_add=False)

파이썬의 datetime.datetime 객체 형태로 표시되는 날짜 필드 입니다. DateField와 인수 옵션은 같습니다.   https://rqentry.com/api/v1/px?xmlid=2wwCbtfAGURZZbzgnBhHaUH3vS5tPwJxUzZTGpnL
EmailField

class EmailField(max_length=254)

CharField의 하위 클래스로 문자열이 이용 가능한 이메일 주소인지 EmailValidator를 통해 확인합니다. 
EmailValidator의 내부 구조가 궁금하다면 아래 문서를 참고하세요.
(https://docs.djangoproject.com/en/3.1/ref/validators/#django.core.validators.EmailValidator)
FileField

class FileField(upload_to=None, max_length=100)

파일 업로드를 위한 필드 입니다.

    upload_to 업로드될 경로를 지정하는 필드로 Storage.save() 함수로 값이 전달되어 저장됩니다. Storage.save 함수 공식문서 (https://docs.djangoproject.com/en/3.1/ref/files/storage/#django.core.files.storage.Storage.save)

ImageField

class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100)

FileField를 상속하여 구현되는 파일 업로드를 위한 필드이며 기본적으로 최대 길이가 100인 문자열 형식으로 생성됩니다. 위에서 나왔던 FileField에서 업로드된 파일이 정상적인 이미지 파일인지 확인하는 과정이 추가된 필드로 이미지 처리를 위한 Pillow 라이브러리가 필수적으로 필요합니다. 이 부분은 뒤에서 함께 다뤄보도록 하겠습니다.

    height_field & width_field 객체가 저장 될 때 이미지의 높이와 너비값이 자동으로 채워 집니다.

이 밖에도 IP 주소를 체크를 하는 GenericIPAddressField, JSON 파일을 위한 JSONField (django 3.1 버전 이상부터 지원) 특정 폴더의 파일 패스를 표현하는 FilePathField, URL을 위한 URLField 등 다양한 필드가 있습니다. 
다음 공식 문서를 참고하세요.
( https://docs.djangoproject.com/en/3.1/ref/models/fields/#django.db.models.Field.default )
옵션(Option)

아래 옵션은 모든 필드 타입에 사용할 수 있으며 선택적으로 적용할 수 있습니다.
null

Field.null

기본 값은 False이며 Null 값 허용 여부를 선택 합니다.

만약 이 null 옵션을 적용할 필드가 문자열 기반 필드 (Char, Text)일 경우에는 주의해서 사용해야 하는데 ' ' (빈 문자열)과 Null 모두 해당 필드의 데이터가 없다는 것을 의미하기 때문입니다. 일반적으로 데이터가 없다는 것을 의미하는 값은 하나여야 하므로 Django는 문자열 기반 필드가 데이터가 없음을 표시할 때는 ' '(빈 문자열)을 사용하도록 권장하고 있습니다.
blank

Field.blank

기본 값은 False이며 True로 설정한 경우 필드 값을 빈 값으로 설정할 수 있습니다.

그렇다면 null과 blank의 차이는 무엇 일까요?
null은 온전히 데이터베이스와 관련된 사항이고 blank는 데이터의 유효성 검사와 관련된 옵션입니다. 예를들어 blank가 True라면 해당 필드에 데이터를 입력하지 않아도 유효성 검사를 통과하게 됩니다.
default

Field.default

필드의 기본값을 설정하는 옵션으로 값 또는 함수가 들어갈 수 있습니다.
db_column

Field.db_column

해당 필드에 사용할 데이터베이스 속성 명을 지정합니다. 따로 지정하지 않을 경우 일반적으로 필드의 이름을 사용합니다.

더 많은 필드와 옵션에 대해 알고 싶다면 아래 django 공식 문서를 참고하세요.
https://docs.djangoproject.com/en/3.1/ref/models/fields/#django.db.models.Field.default



모든 필드와 옵션을 외울 수는 없습니다. 필요할 때 찾아서 사용할 수 있으면 되는 거죠. 다만 찾아보는 연습을 해두어야 찾아야 할 때 참고해서 작성할 수 있습니다. 
공식 문서 보는 것을 두려워하지 마세요. 조금만 관심 있게 보면 친절함이 보인답니다.
----------------------------------------------------------------------------------------------------------------

마이그레이션 (migration)
모델을 만들거나 변경했을 때 장고에 알려줘야한다 이전 강의에서 터미널에 다음 두 명령어를 입력했었다

python3 manage.py makemigrations
python3 manage.py migrate

이 두가지에 대해 자세히 살펴보자 
마이그레이션은 장고의 데이터베이스 변경 사항에 대한 버전 컨트롤 시스템인데 쉽게 말하면 변경 사항을 저장해둔 목록이다
개발자가 모델을 생성하거나 변경했을 때 마이그레이션을 하나씩 만드는거다 그리고 만든 이 마이그레이션을 실재 데이터베이스에 적용하는것이 바로 migrate 명령어이다
조금 더 자세히 봐보자 migration은 각 앱의 migrations 디렉토리에 저장되어있는데 여기를 열여보자 -> 바로 전 강의에 makemigrations 명령어로 만든 0001_inital.py 마이그레이션 파일이 보인다 눌러 보자

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Menu',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=50)),
                ('description', models.CharField(max_length=100)),
                ('price', models.IntegerField()),
                ('img_path', models.CharField(max_length=255)),
            ],
        ),
    ]

 눌러보면 장고에서 제공하는 마이그레이션을 상속 받은 클래스가 있고 (Migration) 안의 내용을 보면 우리가 작성한 부분도 있고 잘 보면 작성하진 않았지만 자동으로 생성된 부분도 있다
 특히 ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 여기의 id는 장고에서 자동으로 생성해주는 필드중 하나인데 각각의 메뉴를 구분하기 위한
 일종의 key (고유값)이다 음식이름으로 각각의 메뉴를 구분할 수 있을것도 같지만 같은 이름의 음식이 여러개 있을수도 있으니 이런 고유값이 필요하겠지~~
 
이렇게 변경사항을 기록한 마이그레이션 파일을 바탕으로 현재 데이터베이스에 적용되지 않은 사항이 있다면 적용해주는 명령어가 바로 migrate 명령어이다 우리는 지금 모델의 모든 코드를 파이썬을 작성했지만 사실 데이터베이스와 
소통하는 과정은 SQL을 사용해야한다 그런데 그런 SQL없이 파이썬 만으로 데이터베이스와 소통해주게 하는것이 뭐였더라? 바로 ORM!
우리가 모델 객체를 파이썬으로 작성하면 장고가 그 코드를 ORM을 통해서 자동으로 SQL로 변환하고 데이터베이스와 소통하게 된다
그럼 한번 파이썬으로 쓴 모델이 어떻게 변환되었는지 볼까? 터미널을 열고 써보자
현재 생성되어있는 마이그레이션 목록을 보려면 

python3 manage.py showmigrations

-> 리스트가 쫙 나온다 왼쪽에  [X] 라고 되있는것들은 이미 장고에 반영이 됬다는 의미이다 foods를 보면 1번 마이그레이션도 이미 장고에 반영이 되었다 그럼 실재로 이 1번 마이그레이션이 ORM을 통해 어떻게
SQL로 변환되었는지 보려면 터미널에 다음과 같이 입력해라

python3 manage.py sqlmigrate foods 000l      (마지막에 앱과 마이그레이션 넘버)

->
BEGIN;
--
-- Create model Menu
--
CREATE TABLE "foods_menu" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(50) NOT NULL, "description" varchar(100) NOT NULL, "price" integer NOT NULL, "img_path" varchar(255) NOT NULL);
COMMIT;

짜잔 SQL 코드가 나온다
----------------------------------------------------------------------------------------------------------------------------------------------
Django의 Migration

마이그레이션(Migration)은 모델(Model)의 변경 사항 즉 Django 프로젝트의 데이터 구조 변경 사항을 관리하기 위한 Django만의 관리 방법입니다. 변경될 때마다 히스토리를 하나씩 만들어 두고 마치 블럭을 갈아 끼우듯 생성한 히스토리를 실제 데이터베이스에 반영하는 거죠. 그리고 이 모든 과정은 Django의 ORM(Object-Relational Mapping)을 통해 진행됩니다.

우리는 앞에서 4가지 명령어를 사용했는데 여기서 간단히 다시 짚어보겠습니다.

    makemigrations
    migrate
    showmigrations
    sqlmigrate

makemigrations

python manage.py makemigrations

모델의 변경 사항을 인식해서 새로운 마이그레이션을 만듭니다. 이때 마이그레이션은 각 앱 디렉토리 내 migrations 디렉토리 안쪽에 생성됩니다.
migrate

python manage.py migrate

생성된 최신 버전의 마이그레이션을 데이터베이스에 반영합니다. 만약 이전 마이그레이션으로 되돌리고 싶다면 python manage.py migrate {앱 이름} {되돌릴 마이그레이션 번호}를 사용할 수 있습니다.
showmigrations

python manage.py showmigrations

현재 django 프로젝트의 모든 마이그레이션과 반영 상태를 나타냅니다. 만약 특정 앱에 대한 것만 보고 싶다면 python manage.py showmigrations {앱 이름}을 사용할 수 있습니다.
sqlmigrate

python manage.py sqlmigrate {앱 이름} {마이그레이션}

인수로 넘겨준 마이그레이션이 ORM을 통해 변경된 SQL문을 출력합니다. sqlmigrate를 통해 모델이 의도한 대로 SQL문으로 변경되어 데이터베이스에 반영되었는지 확인할 수 있습니다.

지금은 마이그레이션에 대해 여기까지 이해하는 것으로 하고 다음 레슨으로 넘어가겠습니다. 천천히 조금씩 Django를 정복해봅시다!
만약 Django의 마이그레이션에 대해 더 알고 싶다면 아래의 공식 문서를 참고하세요.
https://docs.djangoproject.com/en/2.2/topics/migrations/

-------------------------------------------------------------------------------------------------------------------------------
실습과제
코스토랑 프로젝트 #06 모델 작성하기
실습 문제

    코스토랑 프로젝트에 사용할 menu모델을 정의해주세요. 코스토랑의 데이터구조는 아래와 같습니다.

name : 음식이름(한글) , 문자열(str)형, 최대 길이 80
name_eng : 음식이름(영어), 문자열(str)형, 최대길이 80
description : 음식설명 , 문자열(str)형, 최대 길이 120
price : 음식가격, 정수(int)형
img_path : 사진 파일 경로, 문자열(str)형, 최대 길이 255

menus앱의 models.py를 열고 아래를 참고해서 작성해주세요.

class Menu(models.Model):
   field_1 = models.CharField(max_length=100)
   field_2 = models.IntegerField()
   
def __str__(self):
   return self.{음식이름 필드를 넣어주세요}


    migration을 만들고 데이터베이스에 반영해주세요.

python manage.py makemigrations
python manage.py migrate

과제 해설close solution tab
모델 정의하기

실습 문제에서 제시한 데이터의 구조에 맞추어 models.py에 모델을 정의합니다.

class Menu(models.Model):
    name = models.CharField(max_length=80)
    name_eng = models.CharField(max_length=80)
    description = models.CharField(max_length=120)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

데이터베이스에 모델 반영하기

모델의 변경사항에 대한 migration을 만듭니다.
menus/migrations 디렉토리안에 새로운 migraion이 생성됩니다.

python manage.py makemigrations

생성은 되었지만 아직 반영되지 않은 migration을 데이터베이스에 반영합니다.

python manage.py migrate

------------------------------------------------------------------------------------------------------------------------------

데이터 추가하기 (Create)
우리가 만든 모델을 이용해서 데이터베이스에 데이터를 추가해보자 앞으로 이어지는 몇개의 레슨들은 명령창에서 장고의 데이터베이스를 조작하는 법을 배울것이다 터미널을 켜고 입력하라!

python3 manage.py shell   (물론 프로젝트 루트에서 열어야하겠지?)
->
Python 3.9.7 (v3.9.7:1016ef3790, Aug 30 2021, 16:39:15) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)

그러면 이렇게 장고의 유용한 기능들을 다 사용할 수 있는 쉘 환경이 열린다 쉘은 간단히 말하면 사용자의 명령을 받아서 해석한 다음 프로그램을 실행해주는 역할을 한다
자 먼저 코스토랑의 데이터를 다룰 모델을 불러와야한다 foods 앱 안의 models.py 에 있는 Menu를 불러오도록 하자
->
from foods.models import Menu

자 불러왔으니 현재 데이터 베이스에 저장되어 있는 모든 메뉴 데이터를 가져와보자 불러온 모델에다가 .objects.all() 을 입력하면 된다
->
Menu.objects.all()

-> 결과는
<QuerySet []>

QuerySet 이라는게 나오는데 비어있다 당연하다 아무 데이터도 저장 안해줬거든 그럼 한번 데이터를 저장해보자 데이터를 저장할 때는 불러온 모델을 이용해서
objects.create을 입력한 다음에 필드(name, price.. etc)에 접근해서 데이터를 넣어주면 된다
->
Menu.objects.create(name='코딩에 빠진 닭', description='주머니가 가벼운 당신의 마음까지 생각한 가격', price = 10000, img_path = 'foods/images/chicken.jpg')

-> 결과
<Menu: 코딩에 빠진 닭>

이렇게 데이터가 저장된다 잘 저장되었는지 확인해보자

Menu.objects.all()
-> 결과
<QuerySet [<Menu: 코딩에 빠진 닭>]>

두개만 더 입력해보자

Menu.objects.create(name='너는 내게 빠나나', description='바나나 안바나나 바나나', price=2000, img_path='foods/images/banana.jpg')
Menu.objects.create(name='코데리아', description='참깨빵 위에 순쇠고기 패티 세장', price=8000, img_path='foods/images/burger.jpg')

Menu.objects.all()
->
<QuerySet [<Menu: 코딩에 빠진 닭>, <Menu: 너는 내게 빠나나>, <Menu: 코데리아>]>

짜잔
그러면 메뉴 이름뿐만 아니라 모든 데이터를 다 보려면?
->
Menu.objects.all().values()

모든 데이터가 다 나온다

마지막으로 지금 쓰고 있는 쉘을 종료하려면?
->
exit()
----------------------------------------------------------------------------------------------------------------------------------------

Python Shell vs Django Shell
Python Shell

파이썬은 코드가 한 줄 단위로 실행되는 인터프리터 언어입니다. 우리가 파이썬 파일에 엄청난 양의 코드를 적어도 결국 실행될 때는 'line by line' 즉 한줄 한줄씩 실행됩니다. 이때까지 우리는 여러 줄의 파이썬 코드를 파일 단위로 실행하는 것만 해봤습니다. 그런데 이것과 달리 파이썬은 코드를 한 줄씩 실행할 수 있는 환경도 존재하는데요. 파이썬이 제공하는 파이썬 쉘(Shell)이라는 프로그램을 실행하면 이런 환경을 만들 수 있습니다. 터미널 또는 명령 프롬프트에서 'python'을 입력하면 아래와 같이 파이썬 쉘이 실행됩니다.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3893&directory=Untitled.png&name=Untitled.png
Django Shell

Django도 위에서 설명한 쉘 환경, 즉 한 줄씩 Django 코드를 작성하고 실행할 수 있는 환경을 제공합니다. 우리가 앞에서 배웠듯 manage.py를 이용해서 python manage.py shell 커맨드로 실행할 수 있죠. 그리고 실행된 Django 쉘에서는 Django가 제공하는 모든 명령어를 자유롭게 사용해서 결과를 볼 수 있습니다.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3893&directory=Untitled%201.png&name=Untitled+1.png
Python Shell vs Django Shell

두 쉘의 모습만 보면 상당히 비슷해 보이죠? 사실 두 개 모두 같은 파이썬 쉘 환경입니다. 다만 Django 쉘은 Django 프로젝트를 쉘에서 바로 접근 할 수 있도록 하는 환경 설정이 더해진 것입니다. 기존의 파이썬 쉘만으로는 Django에서 제공하는 기능을 사용할 수 없습니다. 이유는 Django가 사용할 환경 설정을 찾지 못하기 때문인데요, Django를 사용하기 위해서는 DJANGO_SETTINGS_MODULE이라는 환경 변수가 필요합니다. 이 환경 변수는 우리 프로젝트의 settings 파일의 위치를 Django에게 알려주는 역할을 합니다. 우리가 manage.py를 통해 Django shell을 실행하게 되면 이 환경 변수를 자동으로 시스템에 등록한 뒤 쉘을 실행하게 됩니다. 아래는 실제 manage.py 파일의 일부인데 보면 os.environ 즉 시스템의 환경 변수에 DJANGO_SETTINGS_MODULE을 등록하는 것을 볼 수 있습니다.

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'costaurant.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

만약 Django의 manage.py를 통하지 않고 기존 파이썬 쉘에서 Django를 사용하고 싶다면 시스템의 환경 변수 목록에 DJANGO_SETTINGS_MODULE 환경 변수를 만들고 '<project_name>.settings'를 변수의 값으로 등록한 뒤에 아래 명령어를 사용해서 Django 쉘과 같은 환경을 만들 수 있습니다.

>> import django
>> django.setup()

이러한 설정을 굳이 할 필요는 없고 우리가 사용하는 Django 쉘이 어떤 것인지 정도만 알고 넘어가는 것으로 충분합니다. 정리하면 Django 쉘도 결국 파이썬 쉘인데 내가 만드는 프로젝트에 대한 설정이 들어가 있는 환경인 것이죠.

----------------------------------------------------------------------------------------------------------------------------------------------

CRUD 
대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능을 묶어서 부르는 말

이번에는 Shell을 이용해서 조금 더 세부적으로 데이터를 조회해 보자 (Read)
저번 코드를 복습해보자

python3 manage.py shell 
from foods.models import Menu
Menu.objects.all()
Menu.objects.all().values()

그럼 이번엔 다른 데이터말고 모든 데이터의 price만 조회하려면?
->
Menu.objects.all().values('price')
-> <QuerySet [{'price': 10000}, {'price': 2000}, {'price': 8000}]>

values는 데이터를 칼럼으로 (각각의 속성으로 조회할 때 사용한다)

데이터베이스에서 데이터를 가져올 때 정렬을 하면서 가져오는 방법은? -? order_by
->
Menu.objects.order_by('price') -> 가격을 기준으로 오름차순으로 정리된 데이터가 나온다
-> <QuerySet [<Menu: 너는 내게 빠나나>, <Menu: 코데리아>, <Menu: 코딩에 빠진 닭>]>

내림 차순으로 정렬하려면?
-> Menu.objects.order_by('-price')   필드 앞에 -을 넣어라

특정 조건을 만족하는 데이터 가져오기

get : 하나의 데이터를 가져올 때
filter : 여러개의 데이터를 가져올 때

이 때 조건 키워드를 사용한다

조건 키워드 : 필드명__조건 키워드 : "조건"

ex) 어떤 문자열이 포함되어 있는 데이터를 조회할 때
Menu.objects.filter(name__contains="코")
-> <QuerySet [<Menu: 코딩에 빠진 닭>, <Menu: 코데리아>]>

ex) 범위 내에 있는 자료를 조회할 떄 -> 필드명__range(시작, 끝)
Menu.objects.filter(price__range=(2000,10000))
-> <QuerySet [<Menu: 코딩에 빠진 닭>, <Menu: 너는 내게 빠나나>, <Menu: 코데리아>]>

filter는 여러개의 데이터를 조회할 때 쓰고 get은 하나의 데이터를 조회할 때 쓴다 만약 get를 썼을 때 조회 결과가 두개 이상히면 에러가 난다

ex)
Menu.objects.get(name__contains="코")
-> 에러가 난다

그럼 get은 언제 사용할까? -> 하나만 있는 데이터를 조회할 때 예를들면 id!
-> Menu.objects.get(id=1)

id는 1부터 순차적으로 매겨지는거 같다
---------------------------------------------------------------------------------------------------------------

데이터 수정, 삭제 (Update, Delete)

데이터 수정부터 해보자

python3 manage.py shell 
from foods.models import Menu

쉘을 켜고 모델 데이터를 가져온다 

data = Menu.objects.get(id=1)

첫번째 데이터를 data 변수에 저장해준다 

data 
-> <Menu: 코딩에 빠진 닭>    잘 들어가있다

데이터를 수정할 땐 필드를 직접적으로 바꿔준다

data.name = "코빠닭"

data 
-> <Menu: 코빠닭>  변경됬다

그런다음 변경 사항을 데이터베이스에 저장한다 

data.save()

이렇게 하면 수정이 끝난다

이번에는 데이터 삭제를 해보자

data.delete()  

그리고 전체 데이터를 출력해보면 id 1번의 데이터가 없다 간단하다!
-------------------------------------------------------------------------------------------------------------------------------------
안녕하세요~~ 강의 수강하다가 한 가지 여쭤봅니다...

데이터 삭제시 

data.delete()를 누른 후,

커맨드 창에 뜨게 되는 

(1, {'foods.Menu': 1})

이 구문의 뜻은 무엇인가용??

반환되는 값은 삭제된 record 가 몇개인지 알려주게 됩니당.


지금과 같이 나오는건 총 1개, foods.Menu 에서 1개를 의미하게 되고용.

https://docs.djangoproject.com/en/3.2/ref/models/querysets/#django.db.models.query.QuerySet.delete

위 공식문서를 참고해보시면
(5, {'weblog.Blog': 1, 'weblog.Entry': 2, 'weblog.Entry_authors': 2})
위와 같이 총 5개, 그리고 어떤 모델에서 각각 지워졌는지를 나타내는 예가 있습니당
-------------------------------------------------------------------------------------------------------------------------
CRUD 더 알아보기

Django는 Model을 통해서 데이터베이스와 소통한다고 했었죠? Django는 Model을 정의하면 ORM을 통해서 데이터베이스에 데이터를 추가하고(Create) 조회하고(Read) 수정하고(Update) 삭제(Delete)할 수 있도록 하는 편리한 기능을 제공합니다. 그러한 기능들은 Model의 'objects'를 이용해서 수행하게 되는데 쉽게 말해서 objects는 Model을 정의하면 생성되는 데이터베이스 관리 매니저로 데이터베이스와 관련된 편리한 기능을 제공하는 객체라고 생각하면 됩니다. 이번 노트에서는 데이터베이스와 소통하는 네가지 방법. CRUD에 대해 조금 더 알아보도록 할게요.
데이터 추가하기 (Create)

데이터를 추가하기 위해서는 import를 이용해서 먼저 사용할 Model을 불러 와야 합니다.

from {app_name}.models import {model}

그 다음 불러온 모델을 이용해서 데이터를 추가하면 되는데 여기에 두가지 방법이 있습니다.
Create

먼저 Create는 데이터 객체를 생성하고 데이터베이스에 반영하는 과정을 한 번에 할 수 있습니다. 생성과 동시에 실제 데이터베이스에 반영이 되는거죠.

data_model = {model}.objects.create( {field_name}=value, ... )
# example
# food = Food.objects.create(price=10000)

Save

save를 이용하면 데이터 객체를 생성하는 타이밍과 실제로 데이터베이스에 반영하는 과정을 
분리할 수 있습니다. 아래 코드는 위에서 사용한 Create와 똑같은 기능을 수행합니다.

data_model = {model}( {field_name}=value, ... )
data_model.save()
# example 
# food = Food(price=10000)
#   food.save()

데이터 조회하기 (Read)

데이터를 데이터베이스로 부터 읽어오는 것은 Django Model Manager인 objects를 통해서 할 수 있습니다. 읽어 온 데이터는 Queryset 이라고 하는 데이터 결과 객체에 들어가며 Queryset은 파이썬의 리스트처럼 사용할 수 있습니다.
모든 데이터 조회하기

데이터 모델의 모든 데이터를 가져오기 위해서는 all()을 사용합니다.

data = {model}.obejcts.all()

하나의 데이터 조회하기

하나의 데이터를 가져오기 위해서는 get()을 사용합니다. 이때 특정 필드를 전달 인자로 넣어 데이터를 가져오거나 아래에서 설명하는 조건 키워드를 함께 사용할 수 있습니다. get은 하나의 데이터를 조회할 때 라는것을 기억해주세요. 만약 get을 사용했을때 조회 결과가 여러개라면 에러를 내게 됩니다.

data = {model}.objects.get(field=value)

조건에 맞는 여러 데이터 조회하기

조건에 맞는 여러 데이터를 조회할 때는 filter()를 사용합니다. 필드를 전달 인자로 넣어 해당 필드 조건에 해당하는 모든 데이터를 가져오거나 아래에서 설명하는 조건 키워드를 함께 사용할 수 있습니다.

data = {model}.objects.filter(field=value)

정렬해서 데이터 조회하기

데이터를 특정 필드에 따라 정렬해서 조회하고 싶을 때는 order_by()를 사용합니다. 이때 두 개 이상의 필드를 함께 사용해서 정렬할 수 있으며 '-'를 사용해서 내림차순으로 정렬할 수 있습니다.

data = {model}.objects.order_by('field_1', '-field_2')
# field_1을 기준으로 오름차순으로 정렬하고 
# 그 결과를 다시 field_2를 기준으로 내림차순으로 정렬합니다.

데이터의 개수 세기

데이터의 개수를 셀 때는 count()를 사용합니다.

rows = {model}.objects.count()

특정 조건을 제외한 데이터 조회하기

특정 조건을 제외한 데이터를 조회하고 싶을 때는 exclude()를 사용해 보세요.

data = {model}.objects.exclude(field=value)
# 특정 field가 value인 데이터를 제외한 모든 데이터를 조회합니다.

체인으로 연결해서 조회하기

여러가지 데이터 조회를 체인처럼 연결해서 사용할 수 있습니다. 아래에서 배우는 조건 키워드도 모두 한 번에 엮어서 사용할 수 있습니다.

data = {model}.objects.filter(price=10000).order_by('name')
# 가격(price)이 10,000원인 데이터를 이름(name)으로 정렬해서 조회합니다.

data = {model}.objects.filter(price=10000)
data = data.order_by('name')
# 이렇게 적어도 위와 똑같은 명령을 수행합니다. 

그러면 체인으로 엮는 방법과 풀어서 아래처럼 쓰는 방법 중에 무엇이 더 좋을까요? 사실 둘 중 어떤 방법을 사용해도 괜찮지만 아래처럼 여러번 나누어 사용하는 것을 추천합니다. Django의 ORM은 매우 강력해서 여러분이 생각하는 거의 대부분의 형태로 구현할 수 이게 해줍니다. 하지만 그러한 강력함 때문에 작성할 때 책임이 따릅니다. 모든 코드는 명확하게 작성할 수록 좋은데 ORM을 통해서 데이터 조회를 하다보면 복잡한 조회를 요구할 때가 많습니다. 복잡한 쿼리를 작성하다보면 체인으로 연결해서 한줄에 작성하는 경우가 많은데 이렇게 복잡한 조회 과정을 하나의 체인으로 묶는것을 지양해야합니다. 그 이유는 첫째로, 체인으로 한 번에 묶는다고 더 빠른 속도로 동작하지 않기 때문이고 두번째로 코드의 가독성이 매우 떨어지기 때문입니다. Django의 ORM은 기본적으로 지연연산(lazy evaluation)으로 이루어집니다. 지연 연산은 우리가 정말로 연산이 필요하기 전까지 연산을 수행하지 않는 것을 말합니다. 그러니까 한 줄로 적는 것과 여러줄 나누어 적는 것이 모두 똑같이 동작한다는 것이죠. 그렇기 때문에 우리는 한 줄로 복잡한 연산을 작성할 필요가 없이 여러 줄로 나누어 적을 수 있고 이런 방식은 코드의 가독성을 매우 높여줍니다.
조건 키워드

모든 데이터 조회는 조건 키워드를 함께 사용하여 조회할 수 있으며 {field_name}__{keyword}={condition} 형태로 사용합니다. 아래는 몇가지 조건 키워드의 예시입니다.

__exact, __iexact

__exact는 대소문자를 구분해서 조건과 정확히 일치 하는지를 체크하며
__iexact는 대소문자를 구분 하지 않고 일치하는 지를 체크합니다.

data = {model}.objects.filter(name__iexact='chicken')
# 음식의 이름(name)이 'chicken'인 데이터를 모두 조회합니다.
# 단, 대소문자를 구분하지 않습니다.

__contains, __icontains

지정한 문자열을 포함 하는지를 체크합니다. 
마찬가지로 __icontains는 대소문자를 구분하지 않고 체크합니다.

data = {model}.objects.filter(name__contains='chicken')
# 음식의 이름(name)에 'chicken'이 포함된 모든 데이터를 조회합니다.
# 단, 대소문자를 구분합니다. (__contains)

__range

지정한 범위 내에 포함 되는지 체크합니다.

날짜, 숫자 문자 등 모든 데이터의 범위를 사용할 수 있으며 파이썬의 range와 비슷합니다.

data = {model}.objects.filter(price__range=(1000,5000))
# 가격(price)이 1000원~5000원인 모든 데이터를 조회합니다.

import datetime
start_date = datetime.date(2020,8,12)
end_date = datetime.date(2020,9,12)
data = {model}.objects.filter(pub_date__range=(start_date,end_date))
# 생성일(pub_date)이 2020-08-12~2020-09-12인 모든 데이터를 조회합니다.

이밖에도 많은 조건 키워드가 있습니다.

__lt , __gt, __lte, __gte

미만 (less-than), 초과 (greater-than)
이하 (less-than-or-equal), 이상(greater-than-or-equal)인 데이터를 조회합니다.

data = {model}.objects.filter(age__gt=25)

__in

주어진 리스트 안에 존재하는 자료를 조회합니다.

data = {model}.objects.filter(age__in=[21,25,27])

이러한 조건 키워드를 조회와 함께 사용하면 복잡한 조회도 SQL없이 구현할 수 있습니다. 이 밖에도 몇가지 조건키워드가 더 있는데 여기서 모든 조건 키워드를 나열하지 않았습니다. '로직을 작성하다가 이런 조건 키워드가 있으면 좋겠는데' 하는 생각이 들때 공식 문서를 참고해서 찾아보세요. 
https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups
데이터 수정하기

데이터를 수정하기 위해서는 수정할 데이터 객체를 가져온 다음 원하는 필드를 수정하고 save()를 호출하여 데이터베이스에 반영하면 됩니다.

data = {model}.objects.get(id=1)
data.name = 'Woojae'
data.save()

데이터 삭제하기

데이터를 삭제하기 위해서는 삭제할 데이터 객체를 가져온 다음 delete()를 호출하면 됩니다.

data = {model}.objects.get(id=3)
data.delete()

모델에 대해 더 많은 내용이 궁금하다면 아래 Django 문서를 참고하세요 :)
https://docs.djangoproject.com/en/2.2/topics/db/queries/

----------------------------------------------------------------------------------------------------------------

QuerySet[]
데이터베이스에서 가져온 결과가 항상 쿼리셋이라는 리스트 안에 담겨 있다 쿼리셋은 장고의 ORM을 이용해 데이터베이스와 소통할 때 발생하는 자료형으로 리스트와 매우 유사하다
데이터 조회를 해서 가져온 데이터는 쿼리셋에 들어가게 되고 우리는 이 퀘리셋을 리스트처럼 이용해서 데이터를 가공할 수 있다 
앞서 모델을 데이터베이스에 반영할 때 어떻게 SQL로 변환되었는지 봤는데 이번에는 CRUD가 어떤 SQL로 변환되는지 보자 

python3 manage.py shell 쉘을 켠다 
from foods.models import Menu 데이터베이스는 모델을 통해 조작하니까 모델도 불러온다 
data = Menu.objects.filter(name__contains="코") 코가 들어간 모든 메뉴
data 데이터 출력

이제 우리가 작성한 이 파이썬 코드가 어떤 SQL로 변환되었는지 함 보자 
->
print(data.query)  지금 퀘리셋인 data 에 .query 를 입력하라 
->
SELECT "foods_menu"."id", "foods_menu"."name", "foods_menu"."description", "foods_menu"."price", "foods_menu"."img_path" FROM "foods_menu" WHERE "foods_menu"."name" LIKE %코% ESCAPE '\'
-> 그럼 SELECT FROM WHERE 절로 조회했다는 것을 알 수 있다 SQL 문법 ~
------------------------------------------------------------------------------------------------------------------------------------------------

관리자 도구 (admin) 사용하기

장고는 많은 기능을 제공해주지만 그 중에서도 관리자 도구를 제공하는것이 큰 장점 앞에서 shell을 이용해 데이터를 다뤘던 과정을 관리자 도구를 이용하면 조금 더 쉽게 할 수 있다

먼저 관리자 계정을 생성해야한다 
터미널-> 프로젝트 루트 -> python3 manage.py createsuperuser -> 순차적으로 id, email, password 입력해서 관리자 계정을 생성하자

자 이제 개발 서버 켜고 domain/admin 으로 접속해보자 -> 방금 만든 관리자 계정으로 로그인 -> 장고에서 기본적으로 생성한 모델이 나온다 Groups와 Users 모델이 있다 그런데 우리가 만든 Menu 모델은 없네?
관리자 페이지에서 작업할 수 있도록 모델을 추가해주는 작업이 필요하다 VSCode 로 가서 foods 앱 안의 admin.py로 가보자
->
from django.contrib import admin

# Register your models here.

여기에 모델을 추가하라고 친절하게 나와있다 추가해주자

from django.contrib import admin
from foods.models import Menu
# Register your models here.
admin.site.register(Menu)

이렇게 등록해주자 다 등록했으면 관리자 페이지 새로고침 해보자 foods 카테고리 안에 Menus라는 항목이 생겼다 열어보자 우리가 데이터 베이스에 넣어주었던 데이터들이 보인다 각각의 항목을 또 눌러보면 모든 데이터들을 볼 수 있다
데이터를 수정할 때도 여기서 바꾸고 세이브 누르면 된다 새로 데이터 추가? Add Menu 라고 써 있는거 누르고 각각의 필드를 입력해준 뒤 세이브를 누르면 데이터가 저장된다 

--------------------------------------------------------------------------------------------------------------------------------------

모델 적용하기 

일단 지금 우리 프로젝트 코딩을 보자 foods 템플릿을 보면 데이터들이 템플릿 안에 그대로 써 있다 이렇게 소스 코드 안에 데이터가 직접 입력도 있는 형태를 하드코딩 이라 한다
이런건 좀 지양해야한다 이렇게 쓰면 코드나 데이터가 바뀌었을 때 자동을 포멧이 변경되지 않기 때문에 데이터가 유실될 수 있고 추후에 유지보수도 힘들다 이 부분들을 바꿔주자
어떻게 할거냐면 index 템플릿에 있는 이러한 데이터들은 뷰에서 모두 넘겨주도록 하고 이 index 뷰는 모델에서 데이터를 모두 가져오도록 하겠다 자 이제 index 뷰를 바꿔보자
veiws.py 로 가자 

def index(request):
    today = datetime.today().date()
    context = {'date' : today}
    # return HttpResponse("<h2>Hello, Django!</h2>")
    return render(request, 'foods/index.html', context = context)

일단 모든 메뉴 데이터를 데이터베이스로부터 가져오자 -> 모델을 import 하자 -> from foods.models import Menu  이걸 위에 추가
그리고 context 변수에는 많은 데이터가 들어가니까 context = {} 이렇게 비어있는 사전형 변수로 나누어주자 
일단 모든 데이터를 가져와서 menus 변수를 만들어 거기다 너준다 -> menus = Menus.objects.all() 
그리고 이 menus를 그대로 템플릿으로 넘겨주도록 하겠다











