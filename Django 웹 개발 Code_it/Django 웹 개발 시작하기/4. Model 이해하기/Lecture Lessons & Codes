Model
모델은 데이터의 구조를 잡아주고 정의된 구조를 기반으로 데이터베이스와 소통한다

데이터 구조
우리가 저장할 정보들의 형태이다 코스트랑에 들어갈만한 정보의 형태는? 우선 코스트랑에는 여러가지 메뉴가 있고 각각의 메뉴마다 음식으 이름 간단한 설명 그리고 가격이 있다
여기서 이름과 설명은 문자(str)의 형태로 저장하면 되고 가격은 숫자형태(int)로 저장하면 된다 이런식으로 각각의 데이터구조와 형식을 정하는것을 데이터 모델릴 (Data Modeling)이라 한다
쉽게 말해 데이터 모델링은 우리 서비스의 요구 사항에 맞게 데이터를 짜는 것이다

실재로 데이터를 저장하는 곳은? 데이터 베이스(Data Base)
대표적인 데이터베이스로는 MySQL, PostgreSQL, Oracle, MongoDB, SQLite 같은 것들이 있다 그리고 이러한 데이터 베이스에 데이터를
추가하거나 (Create) 조회하거나 (Read) 수정하거나 (Update) 지우거나 (Delete) 하는데 이러한 과정을 SQL 이라는 언어를 통해서 한다 
그런데 지금까지 파이썬 html css Django 까지 배우느냐 고생하는데 sql 까지 배우려면 막막하다! 그래서 장고에서는 파이썬을 이용해서 데이터베이스와 소통하게 해주는 도구가 있다
바로 ORM이다

ORM (Object-Relational Mapper)
원래 데이터베이스와 소통하기 위해서는 sql로 된 코드를 길게 써야하는데 이 ORM을 쓰면 파이썬을 이용해 데이터베이스와 소통할 수 있다 이게 어떻게 가능하냐?
장고에서는 Model애서 ORM을 제공한다 우리가 서비스의 요구 사항에 맞게 데이터 모델을 정의한 후 어떤 식으로 파이썬 코드를 쓰면 아 이 모델은 이런 형식으로 데이터를 정의하는구나 하고 장고에서 인식해서
그에 맞는 sql 코드를 자동으로 생성해서 실행하고 우리가 정의해준 형태에 맞게 데이터베이스에 저장된다 그리고 만약 이런 코드를 쓰면 적절한 sql 코드를 자동으로 생성한 다음 실행해서 원하는 데이터를 데이터베이스로부터 
읽어오게 된다 

Model 작성하기
이제 데이터를 웹페이지 파일 자체에 코딩해놓는게 아니라 모델을 이용해서 데이터베이스에 저장해 놓고 필요할 때 꺼내서 사용하자
일단 코스토랑은 음식에 대한 모델 객체가 필요하다 데이터 구조를 어떻게 잡아야할지 데이터 모델링부터 해보자 foods앱의 views.py를 가서 food_detail 함수를 보면 

def food_detail(request, food):
    context = dict() #빈 사전형 생성
    if food == 'chicken':
        context['name'] = '코딩에 빠진 닭'
        context['description'] = '주머니가 가벼운 당신의 마음까지 생각한 가격 !'
        context['price'] = 10000
        context['img_path'] = 'foods/images/chicken.jpg'
    else:
        raise Http404('이런 음식은 없습니다')
    return render(request, 'foods/detail.html', context = context)

하나의 메뉴는 이름과 설명 가격 그리고 이미지로 이루어져있다
그러면 이름과 설명 그리고 이미지 경로는 문자열로 저장하고 음식 가격은 숫자로 저장하면 되겠다
그럼 바로 모델을 작성해보자 foods 앱 안의 models.py 로 가자 모든 모델은 클래스로 구성된다 클래스를 쓰고 이름은 menu라고 하자 

class Menu(models.Model):

그리고 모델 클래스는 장고의 models.Model을 상속받아 구현한다
앞에서 배운 템플릿 상속이 기억나는가? 상속은 공통되는 부분을 모아 부모 객체로 만들고 자식 객체에서는 공통 기능은 부모객체로부터 상속 받아 사용하고 각각 달라지는 부분만 작성한다

맨 처음은 음식 이름을 저장할 구조를 만든다 각각의 데이터에 대한 형식을 필드라고 한다 음식에 대한 name 은 장고에서 제공하는 models를 이용해서 CharField 로 하면 된는데 이 CharField는 저장할 최대 길이를
필수 인수로 넘겨줘야한다 음식 이름 최대 길이를 50으로 하자

class Menu(models.Model):
    name = models.CharField(max_length=50)
  
이렇게 장고에서 제공하는 Field가 여러개가 있는데 지금 다 알아볼 수 없으니 나올때 마다 하나씩 알아보자 다음으로 음식 설명을 위해서 description 변수에 똑같이 CharField 를 만들어주는데 설명이 기니까 100자로 하자
그리고 가격은 숫자니까 IntegerField로 하자 이미지 경로는 문자열이므로 CharField를 쓰고 경로가 길어질 수 있으니 255로 하자

class Menu(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField(max_length=100)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)

그 다음 함수를 하나 정의해준다

class Menu(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField(max_length=100)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)
    
    def __str__(self):
        return self.name

이 __str__ 함수는 이 Menu 클래스는 하나의 문자열로 표현하는 것을 지정해주는 함수이다 print(Menu)를 썼을 떄 결과로 나오는 문자열을 넣어주는 것이다
그리고 여기 return 뒤에 결과로 돌려줄 문자를 적게 되는데 우리는 가각의 음식의 이름을 결과값으로 돌려주도록 하자
자 이렇게 하면 모델작성이 끝났다 생각보다 간단하져? 그리고 이렇게 모델을 새로 작성했거나 중간에 수정했다면 장고에게 사용하는 모델이 바뀌었다고 알려줘야한다
터미널에로 가서 현재 위치를 프로젝트 루트로 바꾼다 그리고 다음의 명령어를 쓴다

python3 manage.py makemigrations (나는 python3로)

콘솔에 다음과 같이 출력된다

Migrations for 'foods':
  foods/migrations/0001_initial.py
    - Create model Menu

모델이 만들어졌다 그 다음에 또 따라서 입력해보자

python3 manage.py migrate

그러면 우리가 만들어준 foods 앱과 더불어 장고에서 미리 만들어주는 여러 데이터 구조들이 함께 반영된다

------------------------------------------------------------------------------------------------------------------------------------
Django의 Model Field

Django Model은 대부분의 데이터를 저장할 수 있는 필드(Field)를 지원하는데 모든 필드에 사용할 수 있는 공통 옵션이 있고, 각각의 필드마다 가지고 있는 고유 옵션이 있습니다. 여기서는 자주 사용할 만한 몇 가지 필드와 옵션을 살펴보겠습니다.
필드(Field)

필드(Field)는 데이터 테이블에서의 열(column), 즉 데이터의 속성을 의미합니다.
CharField

class CharField(max_length=None)

제한된 길이의 문자열을 위한 필드입니다.

    max_length 필수 인수이며 입력할 최대 길이를 설정합니다.

IntegerField

class IntegerField()

정수 값을 위한 필드이며 -2147483648 부터 2147483647 범위를 지원합니다.
BooleanField

class BooleanField()

Boolean 값을 위한 필드 입니다.
DateField

class DateField(auto_now=False, auto_now_add=False)

DateField는 파이썬의 datetime.date 객체 형태로 표시되는 날짜 필드입니다.

    auto_now
      true로 설정되면 해당 객체가 변경(save) 될 때마다 자동으로 필드 값을 지금으로 수정합니다. '마지막 수정 시간' 같은 항목으로 사용하면 좋겠죠?

    auto_now_add
      모델이 처음 생성될 때 한 번, 자동으로 필드 값을 지금으로 설정합니다. '생성된 시간'을 저장하기 위해 많이 사용합니다.

DateTimeField

class DateTimeField(auto_now=False, auto_now_add=False)

파이썬의 datetime.datetime 객체 형태로 표시되는 날짜 필드 입니다. DateField와 인수 옵션은 같습니다.   https://rqentry.com/api/v1/px?xmlid=2wwCbtfAGURZZbzgnBhHaUH3vS5tPwJxUzZTGpnL
EmailField

class EmailField(max_length=254)

CharField의 하위 클래스로 문자열이 이용 가능한 이메일 주소인지 EmailValidator를 통해 확인합니다. 
EmailValidator의 내부 구조가 궁금하다면 아래 문서를 참고하세요.
(https://docs.djangoproject.com/en/3.1/ref/validators/#django.core.validators.EmailValidator)
FileField

class FileField(upload_to=None, max_length=100)

파일 업로드를 위한 필드 입니다.

    upload_to 업로드될 경로를 지정하는 필드로 Storage.save() 함수로 값이 전달되어 저장됩니다. Storage.save 함수 공식문서 (https://docs.djangoproject.com/en/3.1/ref/files/storage/#django.core.files.storage.Storage.save)

ImageField

class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100)

FileField를 상속하여 구현되는 파일 업로드를 위한 필드이며 기본적으로 최대 길이가 100인 문자열 형식으로 생성됩니다. 위에서 나왔던 FileField에서 업로드된 파일이 정상적인 이미지 파일인지 확인하는 과정이 추가된 필드로 이미지 처리를 위한 Pillow 라이브러리가 필수적으로 필요합니다. 이 부분은 뒤에서 함께 다뤄보도록 하겠습니다.

    height_field & width_field 객체가 저장 될 때 이미지의 높이와 너비값이 자동으로 채워 집니다.

이 밖에도 IP 주소를 체크를 하는 GenericIPAddressField, JSON 파일을 위한 JSONField (django 3.1 버전 이상부터 지원) 특정 폴더의 파일 패스를 표현하는 FilePathField, URL을 위한 URLField 등 다양한 필드가 있습니다. 
다음 공식 문서를 참고하세요.
( https://docs.djangoproject.com/en/3.1/ref/models/fields/#django.db.models.Field.default )
옵션(Option)

아래 옵션은 모든 필드 타입에 사용할 수 있으며 선택적으로 적용할 수 있습니다.
null

Field.null

기본 값은 False이며 Null 값 허용 여부를 선택 합니다.

만약 이 null 옵션을 적용할 필드가 문자열 기반 필드 (Char, Text)일 경우에는 주의해서 사용해야 하는데 ' ' (빈 문자열)과 Null 모두 해당 필드의 데이터가 없다는 것을 의미하기 때문입니다. 일반적으로 데이터가 없다는 것을 의미하는 값은 하나여야 하므로 Django는 문자열 기반 필드가 데이터가 없음을 표시할 때는 ' '(빈 문자열)을 사용하도록 권장하고 있습니다.
blank

Field.blank

기본 값은 False이며 True로 설정한 경우 필드 값을 빈 값으로 설정할 수 있습니다.

그렇다면 null과 blank의 차이는 무엇 일까요?
null은 온전히 데이터베이스와 관련된 사항이고 blank는 데이터의 유효성 검사와 관련된 옵션입니다. 예를들어 blank가 True라면 해당 필드에 데이터를 입력하지 않아도 유효성 검사를 통과하게 됩니다.
default

Field.default

필드의 기본값을 설정하는 옵션으로 값 또는 함수가 들어갈 수 있습니다.
db_column

Field.db_column

해당 필드에 사용할 데이터베이스 속성 명을 지정합니다. 따로 지정하지 않을 경우 일반적으로 필드의 이름을 사용합니다.

더 많은 필드와 옵션에 대해 알고 싶다면 아래 django 공식 문서를 참고하세요.
https://docs.djangoproject.com/en/3.1/ref/models/fields/#django.db.models.Field.default



모든 필드와 옵션을 외울 수는 없습니다. 필요할 때 찾아서 사용할 수 있으면 되는 거죠. 다만 찾아보는 연습을 해두어야 찾아야 할 때 참고해서 작성할 수 있습니다. 
공식 문서 보는 것을 두려워하지 마세요. 조금만 관심 있게 보면 친절함이 보인답니다.
----------------------------------------------------------------------------------------------------------------

마이그레이션 (migration)
모델을 만들거나 변경했을 때 장고에 알려줘야한다 이전 강의에서 터미널에 다음 두 명령어를 입력했었다

python3 manage.py makemigrations
python3 manage.py migrate

이 두가지에 대해 자세히 살펴보자 
마이그레이션은 장고의 데이터베이스 변경 사항에 대한 버전 컨트롤 시스템인데 쉽게 말하면 변경 사항을 저장해둔 목록이다
개발자가 모델을 생성하거나 변경했을 때 마이그레이션을 하나씩 만드는거다 그리고 만든 이 마이그레이션을 실재 데이터베이스에 적용하는것이 바로 migrate 명령어이다
조금 더 자세히 봐보자 migration은 각 앱의 migrations 디렉토리에 저장되어있는데 여기를 열여보자 -> 바로 전 강의에 makemigrations 명령어로 만든 0001_inital.py 마이그레이션 파일이 보인다 눌러 보자

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Menu',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=50)),
                ('description', models.CharField(max_length=100)),
                ('price', models.IntegerField()),
                ('img_path', models.CharField(max_length=255)),
            ],
        ),
    ]

 눌러보면 장고에서 제공하는 마이그레이션을 상속 받은 클래스가 있고 (Migration) 안의 내용을 보면 우리가 작성한 부분도 있고 잘 보면 작성하진 않았지만 자동으로 생성된 부분도 있다
 특히 ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 여기의 id는 장고에서 자동으로 생성해주는 필드중 하나인데 각각의 메뉴를 구분하기 위한
 일종의 key (고유값)이다 음식이름으로 각각의 메뉴를 구분할 수 있을것도 같지만 같은 이름의 음식이 여러개 있을수도 있으니 이런 고유값이 필요하겠지~~
 
이렇게 변경사항을 기록한 마이그레이션 파일을 바탕으로 현재 데이터베이스에 적용되지 않은 사항이 있다면 적용해주는 명령어가 바로 migrate 명령어이다 우리는 지금 모델의 모든 코드를 파이썬을 작성했지만 사실 데이터베이스와 
소통하는 과정은 SQL을 사용해야한다 그런데 그런 SQL없이 파이썬 만으로 데이터베이스와 소통해주게 하는것이 뭐였더라? 바로 ORM!
우리가 모델 객체를 파이썬으로 작성하면 장고가 그 코드를 ORM을 통해서 자동으로 SQL로 변환하고 데이터베이스와 소통하게 된다
그럼 한번 파이썬으로 쓴 모델이 어떻게 변환되었는지 볼까? 터미널을 열고 써보자
현재 생성되어있는 마이그레이션 목록을 보려면 

python3 manage.py showmigrations

-> 리스트가 쫙 나온다 왼쪽에  [X] 라고 되있는것들은 이미 장고에 반영이 됬다는 의미이다 foods를 보면 1번 마이그레이션도 이미 장고에 반영이 되었다 그럼 실재로 이 1번 마이그레이션이 ORM을 통해 어떻게
SQL로 변환되었는지 보려면 터미널에 다음과 같이 입력해라

python3 manage.py sqlmigrate foods 000l      (마지막에 앱과 마이그레이션 넘버)

->
BEGIN;
--
-- Create model Menu
--
CREATE TABLE "foods_menu" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(50) NOT NULL, "description" varchar(100) NOT NULL, "price" integer NOT NULL, "img_path" varchar(255) NOT NULL);
COMMIT;

짜잔 SQL 코드가 나온다
----------------------------------------------------------------------------------------------------------------------------------------------
Django의 Migration

마이그레이션(Migration)은 모델(Model)의 변경 사항 즉 Django 프로젝트의 데이터 구조 변경 사항을 관리하기 위한 Django만의 관리 방법입니다. 변경될 때마다 히스토리를 하나씩 만들어 두고 마치 블럭을 갈아 끼우듯 생성한 히스토리를 실제 데이터베이스에 반영하는 거죠. 그리고 이 모든 과정은 Django의 ORM(Object-Relational Mapping)을 통해 진행됩니다.

우리는 앞에서 4가지 명령어를 사용했는데 여기서 간단히 다시 짚어보겠습니다.

    makemigrations
    migrate
    showmigrations
    sqlmigrate

makemigrations

python manage.py makemigrations

모델의 변경 사항을 인식해서 새로운 마이그레이션을 만듭니다. 이때 마이그레이션은 각 앱 디렉토리 내 migrations 디렉토리 안쪽에 생성됩니다.
migrate

python manage.py migrate

생성된 최신 버전의 마이그레이션을 데이터베이스에 반영합니다. 만약 이전 마이그레이션으로 되돌리고 싶다면 python manage.py migrate {앱 이름} {되돌릴 마이그레이션 번호}를 사용할 수 있습니다.
showmigrations

python manage.py showmigrations

현재 django 프로젝트의 모든 마이그레이션과 반영 상태를 나타냅니다. 만약 특정 앱에 대한 것만 보고 싶다면 python manage.py showmigrations {앱 이름}을 사용할 수 있습니다.
sqlmigrate

python manage.py sqlmigrate {앱 이름} {마이그레이션}

인수로 넘겨준 마이그레이션이 ORM을 통해 변경된 SQL문을 출력합니다. sqlmigrate를 통해 모델이 의도한 대로 SQL문으로 변경되어 데이터베이스에 반영되었는지 확인할 수 있습니다.

지금은 마이그레이션에 대해 여기까지 이해하는 것으로 하고 다음 레슨으로 넘어가겠습니다. 천천히 조금씩 Django를 정복해봅시다!
만약 Django의 마이그레이션에 대해 더 알고 싶다면 아래의 공식 문서를 참고하세요.
https://docs.djangoproject.com/en/2.2/topics/migrations/

-------------------------------------------------------------------------------------------------------------------------------
실습과제
코스토랑 프로젝트 #06 모델 작성하기
실습 문제

    코스토랑 프로젝트에 사용할 menu모델을 정의해주세요. 코스토랑의 데이터구조는 아래와 같습니다.

name : 음식이름(한글) , 문자열(str)형, 최대 길이 80
name_eng : 음식이름(영어), 문자열(str)형, 최대길이 80
description : 음식설명 , 문자열(str)형, 최대 길이 120
price : 음식가격, 정수(int)형
img_path : 사진 파일 경로, 문자열(str)형, 최대 길이 255

menus앱의 models.py를 열고 아래를 참고해서 작성해주세요.

class Menu(models.Model):
   field_1 = models.CharField(max_length=100)
   field_2 = models.IntegerField()
   
def __str__(self):
   return self.{음식이름 필드를 넣어주세요}


    migration을 만들고 데이터베이스에 반영해주세요.

python manage.py makemigrations
python manage.py migrate

과제 해설close solution tab
모델 정의하기

실습 문제에서 제시한 데이터의 구조에 맞추어 models.py에 모델을 정의합니다.

class Menu(models.Model):
    name = models.CharField(max_length=80)
    name_eng = models.CharField(max_length=80)
    description = models.CharField(max_length=120)
    price = models.IntegerField()
    img_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

데이터베이스에 모델 반영하기

모델의 변경사항에 대한 migration을 만듭니다.
menus/migrations 디렉토리안에 새로운 migraion이 생성됩니다.

python manage.py makemigrations

생성은 되었지만 아직 반영되지 않은 migration을 데이터베이스에 반영합니다.

python manage.py migrate

------------------------------------------------------------------------------------------------------------------------------

데이터 추가하기 (Create)
우리가 만든 모델을 이용해서 데이터베이스에 데이터를 추가해보자 앞으로 이어지는 몇개의 레슨들은 명령창에서 장고의 데이터베이스를 조작하는 법을 배울것이다 터미널을 켜고 입력하라!

python3 manage.py shell   (물론 프로젝트 루트에서 열어야하겠지?)
->
Python 3.9.7 (v3.9.7:1016ef3790, Aug 30 2021, 16:39:15) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)

그러면 이렇게 장고의 유용한 기능들을 다 사용할 수 있는 쉘 환경이 열린다 쉘은 간단히 말하면 사용자의 명령을 받아서 해석한 다음 프로그램을 실행해주는 역할을 한다
자 먼저 코스토랑의 데이터를 다룰 모델을 불러와야한다 foods 앱 안의 models.py 에 있는 Menu를 불러오도록 하자
->
from foods.models import Menu

자 불러왔으니 현재 데이터 베이스에 저장되어 있는 모든 메뉴 데이터를 가져와보자 불러온 모델에다가 .objects.all() 을 입력하면 된다
->
Menu.objects.all()

-> 결과는
<QuerySet []>

QuerySet 이라는게 나오는데 비어있다 당연하다 아무 데이터도 저장 안해줬거든 그럼 한번 데이터를 저장해보자 데이터를 저장할 때는 불러온 모델을 이용해서
objects.create을 입력한 다음에 필드(name, price.. etc)에 접근해서 데이터를 넣어주면 된다
->
Menu.objects.create(name='코딩에 빠진 닭', description='주머니가 가벼운 당신의 마음까지 생각한 가격', price = 10000, img_path = 'foods/images/chicken.jpg')

-> 결과
<Menu: 코딩에 빠진 닭>

이렇게 데이터가 저장된다 잘 저장되었는지 확인해보자

Menu.objects.all()
-> 결과
<QuerySet [<Menu: 코딩에 빠진 닭>]>

두개만 더 입력해보자

Menu.objects.create(name='너는 내게 빠나나', description='바나나 안바나나 바나나', price=2000, img_path='foods/images/banana.jpg')
Menu.objects.create(name='코데리아', description='참깨빵 위에 순쇠고기 패티 세장', price=8000, img_path='foods/images/burger.jpg')

Menu.objects.all()
->
<QuerySet [<Menu: 코딩에 빠진 닭>, <Menu: 너는 내게 빠나나>, <Menu: 코데리아>]>

짜잔
그러면 메뉴 이름뿐만 아니라 모든 데이터를 다 보려면?
->
Menu.objects.all().values()

모든 데이터가 다 나온다

마지막으로 지금 쓰고 있는 쉘을 종료하려면?
->
exit()
----------------------------------------------------------------------------------------------------------------------------------------

Python Shell vs Django Shell
Python Shell

파이썬은 코드가 한 줄 단위로 실행되는 인터프리터 언어입니다. 우리가 파이썬 파일에 엄청난 양의 코드를 적어도 결국 실행될 때는 'line by line' 즉 한줄 한줄씩 실행됩니다. 이때까지 우리는 여러 줄의 파이썬 코드를 파일 단위로 실행하는 것만 해봤습니다. 그런데 이것과 달리 파이썬은 코드를 한 줄씩 실행할 수 있는 환경도 존재하는데요. 파이썬이 제공하는 파이썬 쉘(Shell)이라는 프로그램을 실행하면 이런 환경을 만들 수 있습니다. 터미널 또는 명령 프롬프트에서 'python'을 입력하면 아래와 같이 파이썬 쉘이 실행됩니다.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3893&directory=Untitled.png&name=Untitled.png
Django Shell

Django도 위에서 설명한 쉘 환경, 즉 한 줄씩 Django 코드를 작성하고 실행할 수 있는 환경을 제공합니다. 우리가 앞에서 배웠듯 manage.py를 이용해서 python manage.py shell 커맨드로 실행할 수 있죠. 그리고 실행된 Django 쉘에서는 Django가 제공하는 모든 명령어를 자유롭게 사용해서 결과를 볼 수 있습니다.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3893&directory=Untitled%201.png&name=Untitled+1.png
Python Shell vs Django Shell

두 쉘의 모습만 보면 상당히 비슷해 보이죠? 사실 두 개 모두 같은 파이썬 쉘 환경입니다. 다만 Django 쉘은 Django 프로젝트를 쉘에서 바로 접근 할 수 있도록 하는 환경 설정이 더해진 것입니다. 기존의 파이썬 쉘만으로는 Django에서 제공하는 기능을 사용할 수 없습니다. 이유는 Django가 사용할 환경 설정을 찾지 못하기 때문인데요, Django를 사용하기 위해서는 DJANGO_SETTINGS_MODULE이라는 환경 변수가 필요합니다. 이 환경 변수는 우리 프로젝트의 settings 파일의 위치를 Django에게 알려주는 역할을 합니다. 우리가 manage.py를 통해 Django shell을 실행하게 되면 이 환경 변수를 자동으로 시스템에 등록한 뒤 쉘을 실행하게 됩니다. 아래는 실제 manage.py 파일의 일부인데 보면 os.environ 즉 시스템의 환경 변수에 DJANGO_SETTINGS_MODULE을 등록하는 것을 볼 수 있습니다.

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'costaurant.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

만약 Django의 manage.py를 통하지 않고 기존 파이썬 쉘에서 Django를 사용하고 싶다면 시스템의 환경 변수 목록에 DJANGO_SETTINGS_MODULE 환경 변수를 만들고 '<project_name>.settings'를 변수의 값으로 등록한 뒤에 아래 명령어를 사용해서 Django 쉘과 같은 환경을 만들 수 있습니다.

>> import django
>> django.setup()

이러한 설정을 굳이 할 필요는 없고 우리가 사용하는 Django 쉘이 어떤 것인지 정도만 알고 넘어가는 것으로 충분합니다. 정리하면 Django 쉘도 결국 파이썬 쉘인데 내가 만드는 프로젝트에 대한 설정이 들어가 있는 환경인 것이죠.

----------------------------------------------------------------------------------------------------------------------------------------------

CRUD 
대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능을 묶어서 부르는 말

이번에는 Shell을 이용해서 조금 더 세부적으로 데이터를 조회해 보자 (Read)
저번 코드를 복습해보자

python3 manage.py shell 
from foods.models import Menu
Menu.objects.all()
Menu.objects.all().values()

그럼 이번엔 다른 데이터말고 모든 데이터의 price만 조회하려면?
->
Menu.objects.all().values('price')
-> <QuerySet [{'price': 10000}, {'price': 2000}, {'price': 8000}]>

values는 데이터를 칼럼으로 (각각의 속성으로 조회할 때 사용한다)

데이터베이스에서 데이터를 가져올 때 정렬을 하면서 가져오는 방법은? -? order_by
->
Menu.objects.order_by('price') -> 가격을 기준으로 오름차순으로 정리된 데이터가 나온다
-> <QuerySet [<Menu: 너는 내게 빠나나>, <Menu: 코데리아>, <Menu: 코딩에 빠진 닭>]>

