로그인, 회원 가입, 게시글 작성 이 세 화면들의 공통점은?
바로 웹 서비스에서 정보를 입력하고 서버와 통신한다는것이다 이렇게 웹 서비스에서 사용자로부터 입력을 받은 데이터를 서버로 전송하기 위한 방식을 form 이라고 한다
이번 챕터에서는 폼의 개념에 대해 알아보고 장고에서 폼 처리하는 법을 배워보자 폼을 다룰 수 있게되면 포스트 작성 수정 삭제 기능을 모두 구현할 수 있다
지금까지 같이 구현헤본 read 조회 기능은 데이터베이스에서 데이터를 가져와 템플릿으로 전송한 뒤 렌더해서 사용자에게 보여주면 되었다 Create은 그 반대로
웹에서 사용자의 입력을 받아서 서버로 전송해주어야한다 이때 사용하는것이 바로 폼이다 먼저 폼이 어떻게 생겼나 보자 이 폼 코드들을 지금 다 이해할 필요는 없다
장고를 이용하면 이러한 폼의 대부분의 요소가 자동으로 만들어지기 때문이다

<form action="next/" method="post">
  <label for ="name">이름</label>
  <input type="text" id="name" name="name"/>
  <label for="email">이메일</label>
  <input type="email" id="email" name="email"/>
  <label for="birth">생일</label>
  <input type="date" id="birth" name="birth"/>
  <input type="submit" value="전송">
</form>

이 코드르 렌더하면

이름
[                   ]
이메일
[                   ]
생일
[연도. 월. 일.    달력]
[전송버튼]

이런식으로 우리에게 익숙한 모습이 된다

HTML 폼은 이렇게 폼 태그 안에 여러 컴포넌트들로 구성되어있다
보면 label과 input이 짝 지어져있는데
  <label for ="name">이름</label>
  <input type="text" id="name" name="name"/>
이 label 부분은 앞에 어떤것을 입력해야되는지 나타내고 input 부분은 실재로 입력하는 곳이 된다

이름   (label)
[                   ]   (input)

그리고 우리가 입력을 하려고 하다 보면 전송하려는 데이터에 따라서 생일처럼 달력 형식으로 입력을 받기도 하고 이름처럼 한줄로 입력을 받기도 한다
이렇게 데이터에 따라 다라지는 입력 형식을 위젯(widget)이라고 한다 그리고 이런 위젝은 input 태그 안의 type에서 결정된다 예를 들어 text라고 하면 한줄로 입력받는 형태가 되고
date 이라고 쓰면 달력 형식으로 나오게된다 이 밖에도 우리가 자주 보았던 체크박스, 라디오버튼 등 기본으로 제공하는 타입이 있고 각각의 위젯을 커스텀해서 JavaScript나 CSS를 함께 사용하기도 한다
다시 폼으로 돌아와서 마지막으로 데이터를 입력했으면 서버로 전송할 수 있는 버튼이 있어야한다 폼에서 전송을 위한 타입이 submit이라고 한다 마찬가지로 Input을 써러 만들어주면 된다
버튼 위에 적은 글씨는 vlaue 속성으로 표현할 수 있다
------------------------------------------------------------------------------------------------------------------------------------------------
폼 처리

form이 처리되는 과정
폼 처리 과정을 이해하려면 일단 GET과 POST 요청에 대해 알아야한다 
클라이언트는 서버에게 요청을 하고 서버는 요청을 받아 처리한 후 응답으로 클라이언트에게 돌려준다 이 때 클라이언트가 보내는 모든 리퀘스트는 서버에게 요청하는 종류에 따라 몇가지 방식으로
나뉘는데 가장 많이 쓰이는 것이 GET과 POST이다

GET은 서버로부터 데이터를 조회할 때 사용한다 GET 방식으로 요청을 보낼 때 요청에 포함하고 싶은 데이터가 있을 수 있는데 GET 방식으로 요청을 보낼 때는 필요한 데이터를 URL에 담아서 보낸다
ex> "지웅"의 프로필 화면을 보여줘 -> 데이터를 url에 담아서 보냄 -> http://example.com/user/profile?name=지웅&email=chojw@codeit.kr&birth=1122

example에 보면 ?가 나오고 여러가지 데이터가 함께 나와있다 이렇게 url 뒤에 붙는 데이터 문자열을 쿼리 스트링이라고 하는데 데이터를 전달하는 가장 단순한 방법이다

query string : 서버에 요청할 때 원하는 것을 상세하게 표현할 때 사용

보면 물음표를 사용해서 url의 끝을 알려주고 그 다음부터는 사전형처럼 키와 밸류의 쌍으로 데이터를 표시하고 각각의 데이터는 &로 구분해준다 
GET 방식으로 요청할 때는 쿼리 스트링을 이용해 클라이언트의 데이터가 서버에 전송된다 자 지금처럼 이름과 이메일 생일 뿐만 아니라 비밀번호나 카드번호 같이 민감한 데이터를 서버에 보내야
할 때도 있는데 이럴 때 url에 데이터를 담아서 전송하는 방식을 적합하지 않다 그래서 데이터를 전송할 때는 POST 방식을 가장 많이 사용한다

Post 
Post는 게시하다는 의미처럼 클라이언트가 서버에 데이터를 변경하는 요청을 할 때 사용한다 그리고 POST 방식의 요청은 쿼리 스트링을 이용하지 않고 클라이언트와 서버가 통신하는 메시지의 안쪽에
데이터를 담기 때문에 url에 노출되지 않는다

CRUD로 생각하면 데이터를 생성하는 것은 서버에게 데이터를 추가 즉 변경하도록 요청하는 것이므로 POST 방식을 사용하고 조회는 서버의 데이터를 변경하는 것이 아니므로 GET 방식을 사용한다
수정과 삭제는 역시 데이터를 변경하는 것이니 POST 방식을 사용한다

우리가 직접 사용하는 예로는 구글에서 검색을 하거나 유투브의 동영상을 볼 때는 모두 GET 방식을 사용한다 서버의 데이터를 변경하는 것이 아니라 서버로부터 데이터를가져오는 것이기 때문
반면에 회원가입 블로그 글쓰기 유투브 동영상 올리기 트위터에 글 수정 삭제하기 등은 서버의 데이터를 변경하는 것이므로 모두 POST 방식을 사용한다 

자 이 차이점을 알았다면 아까 전의 코드를 다시 한번 보자

<form action="next/" method="post">
  <label for ="name">이름</label>
  <input type="text" id="name" name="name"/>
  <label for="email">이메일</label>
  <input type="email" id="email" name="email"/>
  <label for="birth">생일</label>
  <input type="date" id="birth" name="birth"/>
  <input type="submit" value="전송">
</form>

여기 보면 form 태그의 속성으로 action과 method 가 있다 이 부분은 지금 폼에 입력된 데이터를 method 방식 즉 POST 요청을 통해서 action에 해당하는 URL 보내겠다는 뜻이다
그러니까 전송 버튼을 누르면 폼의 데이터를 이 url로 post 요청으로 보낸다는 의미이다 아직 이해가 잘 되지 않을 수 있으니 폼이 처리되는 전체 과정을 한번 보자

첫째 맨 먼저 사용자가 폼을 작성하기 위해 서버에 폼 양식을 요청한다 (회원 가입 페이지 같은거) 그런데 처음 요청할 때는 서버로부터 폼 양식을 조회하는 것이므로 GET 방식을 사용한다
이 부분을 이해하는 것이 중요하다 다시 설명하자면 폼이 있는 페이지를 처음 요청할 때는 서버로부터 해당 페이지를 단순히 조회하는 것이므로 GET 방식을 사용한다 그리고 이렇게 처음 서버가 제공하는
폼을 언 바운드 폼이라고 한다 (unbound form) Bound는 결합된 묶여진 이런 뜻인데 아직 데이터가 묶여있지 안기 때문에 이 상태를 언바운드 폼이라고 한다 

자 두번째로 사용자가 데이터를 입력하고 서버로 전송한다 (회원가입할 때 정보 입력하고 회원가입 버튼을 누른다) 이 때 폼의 method에 명시되어있는 Post 방식으로 action에 해당하는 url로 데이터를 전달한다
데이터를 전달한다는 표현은 다시 말하면 폼의 데이터와 함께 post 방식으로 서버에 요청하는 것이다

세번째, 서버에서 입력된 데이터와 폼을 합쳐서 하나의 형태로 만든다 (데이터 + 폼) 이 과정을 바인딩이라고 한다 이렇게 데이터와 합쳐진 폼을 bound form 이라고 한다

네번째, 만약 바운드 폼에서 가져온 데이터 즉 입력된 데이터가 올바르지 않다면 유효하지 않은 잘못된 데이터이므로 사용자에게 다시 폼을 입력하도록 한다

예를 들어 이름을 입력하는 곳에 숫자를 입력했다면 다시 입력하도록 하는것이다 폼 데이터가 유효할 떄 까지 두번째에게 네번째 단계가 반복된다

다섯번째, 입력된 데이터가 유효하다면 다음으로 서버에 지정한 로직을 수행한다 입력된 데이터를 가지고 가공하거나 수정하거나 뭐 저장하거나 등의 작업을 한다

여섯번째, 작업이 모두 끝났다면 새로운 페이지를 안내한다 다시 말하면 새로운 페이지를 사용자에게 응답으로 돌려준다
-----------------------------------------------------------------------------------------------------------------------------------------------

form이 처리되는 과정 중 맨마지막에 바인딩을 한 후 올바른 값을 입력했을 경우 새로운 페이지를 안내한다고 설명하셨는데,

최근에는 데이터를 입력하고나서 새로운 페이지 안내 없이

 작성데이터가 그 자리에서 업데이트 되는 사이트가 많은 것으로 알고있습니다. 

혹시 이러한 기술은 어떤 원리나 어떤 방법을 사용하여 구현하는 것인가요?? 

제가 이해한 질문이 맞다면 서버단에서 이루어지던 일들이 클라이언트 단에서도 이루어지면서 변화된 내용으로 생각합니다. 

  
Ajax 와 같은 서버와 비동기로 주고받을 수 있는게 등장하면서 기존에는 서버에서 다시 모든 데이터를 가져와서 화면에 렌더링 하는 방식으로 구현하였다면,

Ajax 는 필요한 데이터만 가져올 수 있기 때문에 화면 전환없이 필요한 부분만 클라이언트 단에서 처리를 할 수 있게 된거죵.
--------------------------------------------------------------------------------------------------------------------------

HTML Form

폼은 웹 페이지에서 사용자의 데이터를 입력받을 수 있는 입력 양식을 말합니다.  아래에서 배우는 여러 Form 요소들은 Django에서 제공하는 폼을 사용하면 저절로 생성되지만 기본적인 HTML 폼을 알고 있으면 Django의 폼을 이해하는데 많은 도움이 됩니다.
label과 input

폼은 form태그 안에 사용자의 입력을 받는 input태그와 설명을 위한 label태그의 쌍으로 구성됩니다.

<form>
    <lable>이름</lable>
    <input type="text">
</form>

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled.png&name=Untitled.png
for & id

각각의 input태그와 label태그를 묶어주기 위해서 label태그에는 for 속성, input태그에는 id가 사용됩니다.

<form>
    <label for="title">제목</label>
    <input type="text" id="title">
</form>

만약 여기에서 for와 id 속성을 적어주고 싶지 않다면 label 태그로 input태그를 감싼 형태를 사용하면 됩니다.

<form>
    <label>제목
        <input type="text">
    </label>
</form>

name

name은 입력된 데이터를 서버로 전송할 때, 서버에서 각각의 데이터를 구분하기 위한 속성으로 name 속성이 있는 양식 요소만 값이 서버로 전달됩니다.

<form>
    <label for="title">제목</label>
    <input type="text" id="title" name="title">
</form>

type

type은 입력할 값에 따른 유형을 나타내는 속성입니다. 이 type에 따라 사용자가 브라우저에서 값을 입력하는 형식인 위젯(widget)이 달라집니다. 자주 사용되는 type은 아래와 같습니다.

    email

<label for="email">이메일</label>
<input type="email" id="email" name="email">

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%201.png&name=Untitled+1.png

    password

<label for="pwd">비밀번호</label>
<input type="password" id="pwd" name="pwd">

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%202.png&name=Untitled+2.png

    button

<input type="button" value="버튼입니다">

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%203.png&name=Untitled+3.png

    radio

<input type="radio" id="male" name="gender" value="male">
<label for="male">남자</label><br>
<input type="radio" id="female" name="gender" value="female">
<label for="female">여자</label><br>
<input type="radio" id="other" name="gender" value="other">
<label for="other">기타</label>

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%204.png&name=Untitled+4.png

    checkbox

<input type="checkbox" id="lang1" name="lang1" value="Python">
<label for="lang1">파이썬(Python)</label><br>
<input type="checkbox" id="lang2" name="lang2" value="JAVA">
<label for="lang2">자바(JAVA)</label><br>
<input type="checkbox" id="lang3" name="lang3" value="Go">
<label for="lang3">고(Go)</label><br>

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%205.png&name=Untitled+5.png

    date

<label for="birthday">생년월일</label>
<input type="date" id="birthday" name="birthday">

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%206.png&name=Untitled+6.png

    file

<label for="userfiles">파일선택</label>
<input type="file" id="userfiles" name="userfiles" multiple>

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%207.png&name=Untitled+7.png

    submit

<input type="submit" value="전송하기"> 

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4134&directory=Untitled%208.png&name=Untitled+8.png
form 속성

form에는 입력된 데이터를 전송할 서버의 URL을 지정하는 action과 http 전달 방식을 지정해 주는 method 속성이 있습니다.

<form action="register" method="post">
    <label for="name">이름</label>
    <input type="text" id="name" name="name">
    <input type="submit" value="제출하기">
</form>

GET과 POST

GET 방식으로 지정하면 유저가 데이터를 입력하고 전송했을 때 URL 뒤에 쿼리 스트링(Query String) 형태로 데이터가 전달됩니다.

<form action="/register" method="get">
    <label for="name">이름</label>
    <input type="text" id="name" name="name">
    <label for="email">이메일</label>
    <input type="email" id="email" name="email">
    <input type="submit" value="제출하기">
</form>

http://www.codeit-django.com/register?name=우재&email=woojae@codeit.kr

POST 방식은 전송되는 URL에는 표시되지 않고 서버로 전송하는 메세지 안쪽에 데이터를 넣어서 전달합니다. 이 부분에 대해서는 조금 더 나중에 자세하게 다루겠습니다.

<form action="/register" method="post">
    <label for="name">이름</label>
    <input type="text" id="name" name="name">
    <label for="email">이메일</label>
    <input type="email" id="email" name="email">
    <input type="submit" value="제출하기">
</form>

http://www.codeit-django.com/register

그러면 언제 GET을 사용하고 언제 POST를 사용해야 할까요? 그것을 결정하는 것은 이 요청이 무엇을 하는지에 달려 있습니다. GET은 가져오다는 의미처럼 서버에서 데이터를 가져오는 요청을 보낼 때 사용하고 그 외에 서버의 데이터를 변경하거나 다른 로직을 수행할 때는 POST를 사용합니다. 간단히 정리하면 form을 사용할 때는 사용자로부터 데이터를 입력받아서 저장, 수정 등의 데이터베이스와 관련된 로직을 많이 수행하죠? 그렇기 때문에 form에서는 대부분의 경우 POST를 사용한다고 생각하면 됩니다.

----------------------------------------------------------------------------------------------------------------------------------------

CRUD 중 Create 에 해당하는 블로그 글 쓰기 페이지의 폼을 만들어보자 사용자로부터 입력을 받을 수 있는 형태가 되겠죠? 관리자 페이지의 포스트 작성 페이지를 보자
그런식으로 문자열 형식의 제목과 내용을 입력하는 곳이 있고 SAVE 즉 작성한 데이터를 서버로 전송하는 버튼도 있다 이렇게 세가지 기능을 폼으로 구현해보자

먼저 posts 디렉토리 안에 new file 을 해서 forms.py를 만든다 이곳에서 우리가 사용할 폼을 구현하고 템플릿과 뷰에서는 이 폼을 가져다가 사용만 하면 된다
장고 폼은 Form 클래스는 작성하는것 부터 시작한다 하나의 Form 클래스가 하나의 폼이 되는거다 그대로 따라 적어봐라
->
from django import forms 

class PostForm(forms.Form):

자 모든 Form 클래스는 이런식으로 django forms의 Form 클래스를 상속해서 구현한다 자 그 다음에 이제 클래스 안의 input 항목들을 하나씩 만들어주면 된다
작성하는 방식이 모델을 작성할 때와 매우 비슷하다
->
class PostForm(forms.Form):
    title = forms.CharField(max_length=50, label='제목')
    content = forms.CharField(label='내용', widget=forms.Textarea)

먼저 제목은 title로 그리고 forms 안에 있는 CharField를 이용해서 작성한다 최대길이와 레이블 해준다
그리고 내용은 content라는 변수에 역시 forms의 CharField를 이용해서 작성한다 레이블 해주고 widget 설정도 해준다
자 앞서 보았던 HTML 폼을 떠올려보면 우리가 input 태그를 적을 때 타입 속성에 따라 위젝이 구분된다고 했었다 기본적으로 모든 폼 필드는 해당 필드에 맞는 디폴트 위젝 즉 
기본 위젝을 가지고 있다 날짜를 입력하는 DateField라면 달력모양으로 입력을 받는 위젯 CharField라면 한 줄 입력을 위한 위젝이 기본적으로 설정되어있다
그리고 필요하다면 폼 필드를 정의할 때 위젯을 따로 명시할 수 있다 이 CharField는 기본적으로 TextInput 위젯 즉 한 줄 입력을 위한 위젯을 가지고 있는데
여기 내용의 경우 문자열이긴 하지만 여러 줄 입력을 해야한다 여러줄 입력을 위한 위젯은 Textarea가 있다 그래서 이런식으로 위젯을 설정한다
자 폼에 대한 정의는 이것으로 끝인데 우리가 모델을 정의할 때와 굉장희 비슷하다

이제 뷰에서 이 폼을 가져와서 템플릿으로 보내보자 그 전에 먼저 urls.py로 가서  path('posts/new', views.post_create), 이 부분 주석 해제한다
그 다음에 url name을 정해준다 -> path('posts/new', views.post_create, name="post-create"),

자 그 다음에 views.py 로 가서 post_create 뷰를 작성해주자 그리고 PostForm을 import 해주고 post_form 이라는 변수에다가 PostForm을 사용해보자
->
from .forms import PostForm 추가 

그리고 post_create 뷰

def post_create(request):
    post_form = PostForm()

자 이제 폼을 넘겨주기만 하면 된다 바로 return 해주고 render 해주고 request 해주고 이번에는 posts/post_form.html로 보내주자
대신 이번에는 context 변수를 따로 만들지 않고 form 해준 다음에 post_form 이렇게 해서 넣어주도록 하자 ( 뭐 context 만들어서 넣어줘도 상관은 없자나)
->
def post_create(request):
    post_form = PostForm()

    return render(request, "posts/post_form.html", {'form' : post_form})
    
자 이제 뷰를 만들었으니 템플릿을 만들자 templates/posts 디렉토리에다가 post_form.html을 만들자 자 일단 디자인 요소는 배제하고 간단하게 기능 구현에 집중한다
자 원래라면 앞에서처럼 form 태그를 쓰고 각각의 입력될 컴포넌트를 모두 적어줘야하지만 django의 form 클래스가 대부분 작성해주기 때문에 우리는 form 태그와 서버로
전송을 하기위한 버튼만 만들어주겠다 자 한번 따라 써보라
먼저 <form></form> 이렇게 form 태그를 만들어준 다음에 imnput type="submit" 이렇게 하고 value="전송" 이렇게 적어주자
->
<form>
    <input type="submit" value="전송">
</form>

자 이렇게 하면 이제 폼에서 직접 적어야 하는 부분은 다 됬다 나머지는 뷰에서 넘어온 Form 클래스를 사용한다
->
<form>
    {{form}}
    <input type="submit" value="전송">
</form>

매우 간단하지 않은가? 이렇게만 적으면 폼의 자세한 부분은 Form 클래스를 참고해서 django가 자동적으로 생성한다 한번 확인하자
개발서버를 열고 들어가보자 잘 나온다 그러면 검사(마우스 우클릭 inspect)를 눌러서 이 부분 (내용 입력부분)을 확인해보면 우리가 작성한 django 폼이 label과 input쌍으로
잘 변환되었다는것을 확인할 수 있다 (form 코드로 변환되었다)
->
<html><head></head><body><form>
    <label for="id_title">제목:</label><input type="text" name="title" maxlength="50" required="" id="id_title">
<label for="id_content">내용:</label><textarea name="content" cols="40" rows="10" required="" id="id_content"></textarea>
    <input type="submit" value="전송">
</form></body></html>

다 그럼 다시 템플릿으로 돌아가보자 자 지금은 단순히 폼이라고 써서 label과 input 쌍으로 렌더했는데 장고는 이런 폼을 다른 HTML 컴포넌트와 함께 구조적으로 렌더할 수 있는 옵션을 
제공한다 한번 해보자 form 태그 안에 .as_ul을 붙이자 여기 있는 ul은 unordered list의 약자로 순서가 없는 리스트를 말한다
이렇게 적으면 폼의 각 요소들을 리스트 형식으로 바꿔서 렌더하게 된다 다시 페이지로 가서 새로고침을 하면 이번에는 폼이 이런식으로 li 태그 안에 들어가 있는 것을 알 수 있다 
->
<html><head></head><body><form>
    <li><label for="id_title">제목:</label> <input type="text" name="title" maxlength="50" required="" id="id_title"></li>
<li><label for="id_content">내용:</label> <textarea name="content" cols="40" rows="10" required="" id="id_content"></textarea></li>
    <input type="submit" value="전송">
</form></body></html>

자 이렇게 리스트 형태로 렌더해주는 forms.as_ul 말고도 표 형식으로 렌더해주는 as_table이나 p 태그로 렌더해주는 as_p가 있다
이 점 참고로 알아두도록 하자 

자 그런데 지금 이 페이지에서 우리가 아무 제목 아무 내용을 넣어서 전송을 눌러도 아무런 변화가 없다 이건 폼만 작성했을 뿐 아직 다른 로직은 구현하지 않아서 그렇다
이 부분은 다음 시간에 하자
-----------------------------------------------------------------------------------------------------------------------------------------
실습과제
일기장 페이지 만들기

이번에는 일기를 입력할 수 있는 폼을 만들어 보겠습니다. 아래를 참고해서 작성해 주세요.

    models.py를 보면 우리가 작성해야 하는 필드는 총 5개 입니다.

    title = models.CharField(max_length=100)
    content = models.TextField()
    feeling = models.CharField(max_length=80)
    score = models.IntegerField()
    dt_created = models.DateField()

    diary 디렉토리에 forms.py를 생성하고 아래를 참고해서 PageForm을 작성해 주세요.

    from django import forms

    class PageForm(forms.Form):
        ...

    # 폼 필드 목록

    # 아래를 참고해서 작성해 주세요.
    title -> CharField, 최대 길이 100자, label='제목'
    content -> CharField, widget=forms.Textarea, label='내용'
    feeling -> CharField, 최대 길이 80자, label='감정 상태'
    score -> IntegerField, label='감정 점수'
    dt_created -> DateField, label='날짜'

    urls.py로 가서 일기 작성에 해당하는 URL 패턴의 주석을 해제해 주세요.

    views.py에 아래를 참고하여 page_create 뷰를 작성해 주세요.

    from .forms import PageForm # 사용할 form을 가져와야 합니다.
    form = PageForm() # 작성한 폼을 이용해서 form을 생성합니다.

        page_create 뷰는 page_form.html을 랜더 해서 결과로 돌려주는데, 이때 'form'이라는 키워드로 생성한 PageForm을 context로 넘겨주도록 작성해 주세요.

    page_form.html로 가서 p 태그 형식으로 form을 랜더 하도록 작성해 주세요.

    base.html로 가서 일기 쓰기로 이동하는 링크에 page-create를 연결해 주세요.

    개발 서버를 켜고 /diary/로 이동한 후 '일기 쓰기'를 눌러서 아래와 같이 폼이 나오는지 확인합니다. 지금은 아무런 동작을 하지 않아요 ! 입력할 수 있는 폼이 잘 나온다면 ok !

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4136&directory=Untitled%201.png&name=Untitled+1.png

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4136&directory=Untitled%202.png&name=Untitled+2.png

과제 해설close solution tab

    diary/forms.py 안에 PageForm 클래스를 작성합니다. Form 클래스는 Django의 forms.Form을 상속하고 각각의 폼 필드를 작성하면 됩니다. 이때 content 같은 경우 여러줄 입력이 가능한 Textarea 위젯을 파라미터로 넘겨주어 위젯을 명시해 줍니다. 명시하지 않은 다른 폼 필드들은 각 필드 타입에 따른 기본 위젯으로 설정 됩니다.

    from django import forms

    class PageForm(forms.Form):
        title = forms.CharField(max_length=100, label='제목')
        content = forms.CharField(widget=forms.Textarea, label='내용')
        feeling = forms.CharField(max_length=80, label='감정 상태')
        score = forms.IntegerField(label='감정 점수')
        dt_created = forms.DateField(label='작성일')

    urls.py로 가서 일기 작성에 해당 하는 URL의 주석을 해제 합니다.

    from django.urls import path
    from . import views

    urlpatterns = [
        path('diary/', views.page_list, name='page-list'),
        path('diary/info/', views.info, name='info'),
        path('diary/write/', views.page_create, name='page-create'), # 주석 해제
        path('diary/page/<int:page_id>/', views.page_detail, name='page-detail'),
        # path('diary/page/<int:page_id>/edit/', views.page_update, name='page-update'),
        # path('diary/page/<int:page_id>/delete/', views.page_delete, name='page-delete'),
    ]

    이제 views.py로 가서 page_create 뷰를 작성하면 됩니다. page_create 뷰는 page_form 템플릿을 랜더해서 결과로 돌려주는데 이때 작성했던 PageForm을 page_form 템플릿으로 함께 넘겨주도록 작성하면 됩니다.

    from django.shortcuts import render
    from .models import Page
    from .forms import PageForm

    ... 

    def page_create(request):
        form = PageForm()
        return render(request, 'diary/page_form.html', {'form': form})

    ...

    그리고 아직 page_form 템플릿을 작성한 적이 없죠? page_form 템플릿을 작성합니다. 보면 미리 form 태그와 작성하기 버튼이 작성되어 있는데 여기에 page_create 뷰에서 넘겨준 form을 이용해서 작성합니다. 각각의 입력 요소들을 p 태그로 랜더해주는 as_p를 사용하겠습니다.

    <form method="post">
        {{form.as_p}}
        <input type="submit" value="작성하기">
    </form>

    이렇게 작성하면 forms.py에서 작성한 대로 각각의 폼 필드에 알맞은 형태로 html 태그가 생성됩니다.

    마지막으로 base.html로 가서 '일기 쓰기'로 이동하는 링크에 지금 작성한 page-create를 연결해 주면 됩니다. url 템플릿 태그를 이용하면 되겠죠?

    {% load static %}
    <!DOCTYPE html>
    <html lang="en">
    ...
    <body>
        <div class="menu">
            <h1><a href="{% url 'page-list' %}"><img src="{% static 'diary/image/logo02.svg' %}"></a></h1>
            <ul>
                <li><a href="{% url 'page-list' %}">모아보기</a></li>
                <li><a href="{% url 'info' %}">감정일기란</a></li>
                <li><a href="{% url 'page-create' %}">일기쓰기</a></li>
            </ul>
        </div>
        {% block content %}
        {% endblock content %}
    </body>

    다 되었습니다. 개발 서버를 켜고 /diary/로 이동해서 '일기 쓰기'를 눌러 일기 작성 폼이 잘 나오는지 확인합니다. 아직 폼이 입력은 되지만 동작은 하지 않습니다. 이 부분은 다음 실습에서 작성해 보도록 할게요.

----------------------------------------------------------------------------------------------------------------------------------------------------------

포스트 작성 페이지

이번에는 장고 폼을 처리하는 로직을 넣어서 포스트 작성 페이지를 완성해보자
폼 처리과정의 첫번째는 유저가 폼을 작성하는 페이지를 서버에 요청하는것이다 우리가 이렇게 domain/posts/new로 들어오면 그건 곧 서버에 요청을 하는 것이니까 폼 처리과정의 첫번째 단계다 그리고 이 때의 요청은
우리 서버에게 GET 방식으로 요청을 하게된다 잠깐 복습을 하자면 모든 요청은 서버에 요구하는 것에 따라 몇가지 방식으로 나뉘는데 대표적으로 GET과 POST가 있다 서버에 데이터 변경을 요청하는 POST 그 외에 일반적인 
조회 요청은 GET 방식을 이용하는데 그러면 지금 우리의 post_form을 보자
->
<form>
    {{form.as_ul}}
    <input type="submit" value="전송">
</form>

앞에서 폼에 대해 배울 때 폼에다가 action="" 또 이런식으로 method=""를 적어줄 수도 있었다 
<form action="" method="">
    {{form.as_ul}}
    <input type="submit" value="전송">
</form>

자 여기에 action 같은 경우에는 우리의 폼을 정달할 서버의 url을 적어주는곳이고 여기 이 method의 경우에는 이 폼 데이터를 담아서 서버에 요청할 때 즉 서버에 전송할 때 어떤 방식으로 전송할지를 적어주는 곳이다
<form>
    {{form.as_ul}}
    <input type="submit" value="전송">
</form>
그리고 바로 위처럼 아무것도 안적게되면 기본적으로 action에는 현재 있는 url이 들어가게 되고 method는 GET을 사용하게된다 
자 action이 현재 url이라는 것은 여기 이 부분이죠? (<input type="submit" value="전송">) 전송 버튼을 누르면 현재 페이지의 url로 다시 요청을 하게되는데
이 때는 폼 데이터인 이 부분을({{form.as_ul}}) 담아서 보낸다는 의미다 같은 url로 다시 전송한다는 것이 조금 헷갈릴 수도 있는데 지금은 완벽하게 이해안가도 된다
뒤에서 로직을 구현하다보면 아마 자연스럽게 이해가 될것이다 그러면 코드를 작성해보자 따라해보자 
method는 post라고 적어준다 이렇게 하면 데이터를 입력하고 전송을 누르게되면 post 방식으로 서버에 전송된다 그리고 action을 따로 적어주지 않았으니 현재 url 즉 여기 적힌 url로(domain/posts/new) 데이터를 전송하게 된다
이 부분은 뷰에서 처리하는 로직을 배우면 좀 더 명확해질테니 기다려라 그리고 form 태그 뒷부분에다가 crst_token 템플릿 태그를 적어준다
여기서 crsf는 cross site request forgery의 약자로 교차 사이트 위조 검증 이렇게 말하는데 쉽게 말하면 내가 하지 않은 요청을 내가 한 것처럼 위조하는 것을 방지하기 위한 보안 기술이다
뭐 이 기술이 어떻게 작동하는지는 잘 알 필요 없고 폼 처리할 때는 장고가 제공하는 crsf 템플릿 태그를 사용한다 이렇게만 알아두자
->
<form method="post">{% csrf_token %}
    {{form.as_ul}}
    <input type="submit" value="전송">
</form>

자 이제 템플릿 작성은 다 끝났다 작성한 코드가 얼마 안되는데 이렇게 작성한 폼에 유저가 데이터를 입력하고 전송을 눌러 데이터를 서버에 보내는 것이 폼 처리의 두번째 단계이다 
이 다음부터는 이제 서버에서 데이터를 받아서 처리해주는 단계인데 로직을 작성하는 views.py로 가보자 자 이제는 데이터를 서버에서 처리하는 과정을 작성해보자     

def post_create(request):
    post_form = PostForm()

    return render(request, "posts/post_form.html", {'form' : post_form})

일단 로직에 대해 간단히 말하면 위에서 request 요청이 POST 방식으로 들어오면 그러니까 urls.py에서 post/news로 POST 방식으로 요청이 온다면 이 때는 유저가 폼의 데이터를 작성하고 전송을 눌렀을 때다 그렇기 때문에
if request.method == "POST" 그러니까 유저가 폼에 데이터를 입력하고 전송 버튼을 눌렀을 때라면 우리는 유저가 입력한 데이터를 가져와서 모델을 이용해 데이터베이스에 저장하면 된다 그러면 POST 요청에서 데이터를 가져와보자
title = request.POST['title']
content = request.POST['content']
이렇게 해주면 요청에서 데이터를 가져올 수 있다
new_post = Post(
  title = title,
  content = content
)
new_post.save()
그다음에 new_post 란 변수에다가 Post 해주시고 안에 위에처럼 작성한다 그러면 Post 모델을 이용해서 데이터를 생성하고 이 생성한 데이터를 new_post.save()로 저장해준다
이런 과정은 앞에서 쉘을 이용해서 데이터베이스를 조작할 때 한번 해봤다

자 다음엔 이렇게 데이터를 저장하고 난 다음 방금 저장했던 글을 보는 상세 글 보기 페이지 즉 디테일 페이지로 이동하게 해보자
->  return redirect('post-detail', post_id=new_post.id)

지금처럼 다른 url로 이동할 때는 이 redirect 이라는걸 쓰는데 말 그대로 다른 페이지로 연결해주는 함수다 일단 이걸 쓰려면 from django.shortcuts import redirect 이렇게 해주자 
from django.shortcuts import render 그냥 이 옆에 from django.shortcuts import render, redirect 이렇게 해줘도 된다          
다시 return redirect('post-detail', post_id=new_post.id) 이 부분을 설명하자면 'post-detail' 이 부분은 어디로 이동할지를 적어주는 부분인데 지금은 url의 네임을 적어줬다 url을 문자열로 하드코딩
하는것보단 url name을 적어주는게 더 좋기 때문에 이런식으로 적어주고 그 다음에 urls.py를 보면 detail 페이지로 가려면 post_id가 필요했다 ('posts/<int:post_id>/') 그렇기 때문에 post_id=new_post.id
여기서 post_id를 데이터베이스에 저장될 데이터의 id값을 이용해서 상세보기 페이지로 이동시키는 것이다 즉 새로 생성한 Post 모델의 id 값이 post_id가 되는거다
즉 이 코드를 한번 정리해보자면 요청에서 유저가 입력한 데이터를 가져온 다음 데이터를 만들어주고 그 데이터를 데이터베이스에 저장한다 그리고난다음 상세보기 페이지로 이동을 시켜준다 
자 마지막으로 요청 method가 POST 가 아닐 경우도 써보자 else를 해주고 그 안에 코드를 작성하는데 그 전에 위에는 POST 방식이고 밑에는 POST 방식이 아닐 때니까 GET 방식으로 생각해주면 된다
보통 이 GET 방식은 유저가 데이터를 입력하기 전 그러니까 처음으로 여기 posts/new 이 url로 접속을 하면 유저는 서버로 요청을 하게 되는데 그 요청이란 우리가 데이터를 입력할 수 있는 폼을 달라는 의미이다 그러니까 서버에서는
유저들이 데이터를 입력할 수 있는 폼을 돌려줘야겠지? 그러니까 원래 맨 밑에 있던 두줄을 else 안으로 이동시켜 이렇게 작성해주자
->
def post_create(request):
    if request.method == 'POST':
        title = request.POST['title']
        content = request.POST['content']
        new_post = Post(
            title = title,
            content = content
        )
        new_post.save()
        return redirect('post-detail', post_id=new_post.id)
    else:
        post_form = PostForm()
        return render(request, "posts/post_form.html", {'form' : post_form})

개발서버 열고 코드 잘 동작하는지 확인해보자 글하나 새로 써보자 잘 작동되나 확인해보자~

아 그리고 지금 post_list 템플릿에 글쓰기 버튼이 없는데 이것도 하나 만들어주자
->     <a href="{% url 'post-create' %}">글쓰기</a>

content 블락 시작 태그 바로 밑에 a 태그 하나 만들어주자~ 그리고 개발서버 키고 확인해보자 잘 나오는데 좀 못생겼다 css좀 적용시켜주자
a태그를 div로 감싸고 'btn-post' 클래스로 만들어주자 이 클래스에 대한 스타일은 강의 css에 이미 구현되있다 내가 할필요 없다
개발서버 새로고침 헤보면 이쁘게 잘나온다 

지금까지 잘했다 근데 지금은 입력된 데이터가 정상적인 데이터인지 검사하는 유효성 검사를 아직 안했는데 이 부분은 뒤에서 자세하게 다루겠다
----------------------------------------------------------------------------------------------------------------------------------
강의에 보면 else 일 때 그러니까 request.method가 post 가 아닐때 request.method는 get이라고 하셨는데

form 을 호출하기 전에 urls.py를 통해서 view를 호출할 때는 request.method 값이 항상 get인가요?

form 처리 바로 이전 단계를 말씀하시는 거라면

GET 요청이 맞을거라 생각합니당.
---------------------------------------------------------------------------------------------------------------------

redirect 메서드는 다음과 같은 구조를 갖고 있다고 들었습니다.
redirect(to, permanent=False, *args, **kwrags)
강의를 보면 return redirect('post-detail', post_id=new_post.id) 이렇게 나오는데
'post-detail'은 to에 해당하는거 같지만 post_id=new_post.id 이 부분은 어디에 해당하는건가요?

redirect 는 내부적으로 resolve_url 메서드를 반환합니당.

이 resolve_url 은 다시 내부적으로 reverse 메소드를 반환하는데

django.urls utility functions | Django documentation | Django (djangoproject.com) 을 확인해보시면

reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)

여기서 kwargs 에 post_id=new_post.id 가 넘어갈거에용

그래서

 redirect('post-detail', post_id=new_post.id)

이렇게 쓰게 되면 

reverse('post-detail', kwargs={'post_id': new_post.id})

와 같다고 생각하시면 될겁니당. 즉 redirect 메서드에서 **kwargs 로 인식되는거죵

함수 정의에서 **kwargs 와 같이 쓰는건 키워드 파라미터인데, kwargs, 즉 keyword arguments 약자를 관습적으로 사용하게 됩니당.

그래서 호출할 때 아래와 같이 key 와 value 를 넣어주면 함수 내부에서 dictionary 형태로 들어가게 됩니당.

def print_something(**kwargs):
    print(kwargs)
  
print_something(englsih="영어")

# 출력
{'englsih': '영어'}

-----------------------------------------------------------------------------------------------------------------------------------------
CSRF 방지

크로스 사이트 요청 위조(CSRF, Cross-Site Request Forgery)는 간단히 말하면 웹 사이트에서 유저가 서버로 요청을 보내는 행위를 악의적으로 변경해서 요청을 전송하는 것입니다. 내가 요청하지 않은 일인데 내가 요청한 것처럼 처리되는 거죠.
크로스 사이트 요청 위조

Cross-Site라는 말이 붙은 이유는 악성 사이트에서 보안이 취약한 사이트로 우회 요청을 보내기 때문인데요. 예를들면 다음과 같은 단계로 요청 위조가 일어날 수 있습니다.

    유저가 보안이 취약한 사이트(www.example-weak.com)에 로그인을 합니다. 아이디와 패스워드등의 유저 입력을 받아서 서버로 전송해야 하니까 폼(Form)을 사용하겠죠?

    서버가 유저가 전송한 정보를 보고 이 유저가 정상유저임을 인증합니다. 로그인이 성공한 상태죠. 이때 보이지 않지만 서버로부터 인증된 유저라는 정보가 유저에게도 전달되게 됩니다. 이 정보를 사용해서 서버는 매번 로그인을 요청 하지 않고도 이 유저가 로그인 한 유저라는 것을 식별하는거죠.

    이 상태에서 유저가 로그아웃 하지 않은 채, 악성 사이트(www.example-malicious.com)로 이동합니다. 우리가 웹 서핑을 할 때 흔히 하는 동작이죠.

    그러면 이제 악성 사이트에서 다음과 같은 유저의 정보를 가져오거나, 돈을 송금하는 등의 요청을 전송하는 폼을 누르게 하거나 해당 폼을 굳이 작성하지 않아도 자동으로 전송 되는 형태로 요청을 시도합니다. action을 보면 지금 악성 사이트에서 취약한 사이트로 요청을 보내고 있죠? 크로스 사이트 요청이 일어나는 부분입니다.

    <form action="www.example-weak.com/user-info/account" method="post">
        <div>응모에 당첨되셨습니다!</div>
        <label type="hidden" name="withdraw" value="withdraw"> # 숨김 처리된 input
        <label type="hidden" name="amount" value="1000000">  # 숨김 처리된 input
        <input type="submit" value="경품받기">
    </form>

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4137&directory=Untitled.png&name=Untitled.png

    요청을 보낼 때 유저가 가지고 있는 인증 정보도 함께 서버로 전송됩니다.

    취약한 사이트에서는 인증된 유저가 보낸 요청이므로 요청을 수행하게 됩니다.

위조 방지 토큰

위에서 보았던 크로스 사이트 요청 위조를 방지하는 방법으로 많이 사용하는 것이 바로 CSRF 위조 방지 토큰(Cross Site Request Forgery Token)입니다. 요청 위조 방지 토큰은 서버로부터 폼을 요청할 때 발행되어 유저가 폼에 데이터를 입력하고 서버로 전송할 때 이 토큰 값을 함께 전달해서 서버에서 토큰 값을 비교한 뒤 요청을 처리하는 방식을 말합니다. 그래서 요청 검증 토큰(Request Verification Token)라고 부르기도 합니다. 이렇게 처리하면 위의 예시에서 악성 사이트가 폼을 전송할 때 이 위조 방지 토큰 값을 알 수 없기 때문에 서버에서 사용자가 직접 보낸 요청인지를 검증할 수 있게 되는 거죠.
Django의 CSRF 방지

Django는 CSRF 위조 방지를 기본 기능으로 제공해서 위조 방지 토큰을 삽입하고 검증하는 과정을 간단하게 구현할  수 있습니다. 폼을 사용하는 템플릿에 아래 처럼 {% csrf_token %} 템플릿 태그를 적어 주면 됩니다.

<form action="/user" method="post">{% csrf_token %}
    ...
</form>

이 밖에도 다양한 외부 라이브러리를 함께 이용할 때 사용할 수 있도록 Django는 개별적으로 CSRF 방지를 구현할 수 있는 방법도 제공하는데 지금은 CSRF 방지가 무엇인지 그리고 Django에서는 어떻게 기본적으로 구현할 수 있는지만 기억해주세요.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

실습과제
감정 노트 작성 페이지 만들기

아래를 참고해서 실제로 동작하는 일기 작성 페이지를 만들어 주세요.

    page_form 템플릿에 CSRF를 방지 할 수 있도록 코드를 작성해 주세요.

    아래를 참고해서 page_create 뷰를 작성해 주세요.
    POST

    아래는 요청이 post 방식으로 들어왔을 때의 로직입니다.

    def page_create(request):
            # 만약 POST 방식으로 요청이 들어오면
                # 작성한 데이터를 가져와서 새로운 Page 데이터 모델을 만들고
                # 데이터를 저장한 후
                # 방금 작성한 상세 일기 보기 페이지로 이동합니다.

    그럼 하나씩 구현해봅시다. 먼저 request로 부터 사용자가 입력한 데이터를 가져와서 새로운 Page 데이터 model을 생성하고 데이터 베이스에 저장합니다.

    # 데이터 가져오기 
    new_page = Page(
        title = request로 부터 가져온 데이터
        ...
    )

    # 데이터 저장

    그 다음 모든 로직이 완료 되었으므로 방금 저장한 데이터를 보여주는 page-detail 로 redirect 합니다. 이때 page의 id값이 필요하겠죠?

    from django.shortcuts import redirect # redirect를 먼저 import 해야합니다.

    ...
    return redirect(...)

    GET

    요청이 post 방식이 아닐 때는 기존의 코드대로 새로운 form을 생성하고 page_form 템플릿을 랜더해서 결과로 돌려주도록 작성해 주세요.

    def page_create(request):
        # 만약 POST 방식으로 요청이 들어오면
            # POST 로직 ...
        # GET 방식 이라면
            # PageForm을 이용해서 새로운 form을 생성하고
            # 생성한 form을 전달받은 page_form 템플릿을 랜더해서 결과로 돌려줍니다.

    개발 서버를 켜고 일기 작성 페이지로 이동한 뒤 새로운 일기를 자유롭게 작성해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4138&directory=Untitled.png&name=Untitled.png

    '작성하기'를 눌러서 새로 쓴 글로 이동하는지 확인해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4138&directory=Untitled%201.png&name=Untitled+1.png

과제 해설close solution tab

    Django는 CSRF를 방지할 수 있는 템플릿 태그를 제공합니다. {% csrf_token %}을 form에 작성하면 CSRF를 자동으로 방지하는 로직을 수행하게 됩니다.

    <!-- page_form.html -->
    <form method="post">{% csrf_token %}
        {{form.as_p}}
        <input type="submit" value="작성하기">
    </form>

    page_create 뷰는 요청 방식(GET, POST)에 따라 수행하는 로직이 다릅니다.
    POST

    먼저 POST 방식으로 요청이 들어왔을 때는 사용자가 폼에 데이터를 입력한 후 전송 버튼을 누른 것이므로 요청(request)으로 부터 데이터를 가져와서 데이터를 저장하고 저장된 데이터를 볼 수 있는 상세 일기 보기 페이지로 안내합니다.

    def page_create(request):
        if request.method == 'POST': # 만약 요청 방식이 POST라면
            new_page = Page( # 입력된 데이터를 가져와서 Page 데이터 모델을 만들고
                title=request.POST['title'],  
                content=request.POST['content'],
                feeling=request.POST['feeling'],
                score=request.POST['score'],
                dt_created=request.POST['dt_created']
            )
            new_page.save() # 데이터베이스에 저장한 후
            return redirect('page-detail', page_id=new_page.id) # 상세 일기 보기 페이지로 안내합니다.

    이때 redirect에서 이동할 URL을 하드코딩 하는 것 대신 url-name을 사용하는 것이 권장되며 page-detail은 상세 보기를 할 데이터의 page_id가 필요하므로 키워드를 함께 전달합니다. 방금 우리가 생성한 Page 데이터 모델의 id값을 넘겨주면 되겠죠?
    GET

    GET 방식으로 요청이 들어왔을 때는 사용자가 처음 일기 작성 페이지에 들어왔을 때, 즉 입력할 폼을 요청할 때 입니다. 따라서 PageForm을 이용해서 새로운 form을 생성한 후 page_form 템플릿으로 생성한 form을 넘겨준 다음 템플릿과 함께 렌더해서 결과로 돌려주도록 작성하면 됩니다.

    def page_create(request):
        if request.method == 'POST':
            ...
        else: # 만약 요청 방식이 GET이라면
            form = PageForm() # 새로운 form을 만들고 (빈 폼)
            return render(request, 'diary/page_form.html', {'form': form}) 
                    # 템플릿으로 보내 렌더해서 결과로 돌려줍니다.

    개발 서버를 켜고 글 작성이 정상적으로 되는지, 작성 후 상세 보기 페이지로 잘 이동하는지 확인해 주세요.

----------------------------------------------------------------------------------------------------------------------------------------------
감정일기 과제 중 

views.py 에서 아래와 같이 코드를 작성했습니다.

def page_create(request):
    if request.method == "POST":
        title = request.POST['title']
        content = request.POST['content']
        feeling = request.POST['feeling']
        score = request.POST['score']
        dt_created = request.POST['dt_created']
        new_page = Page(
            title = title,
            content = content,
            feeling = feeling,
            score = score,
            dt_created = dt_created
        )
        new_page.save()
        return redirect('page-detail', page_id=new_page.id)
    else:
        form = Postform()
        return render(request, 'diary/post_form.html', {'form':form})

위 페이지에서 일기 작성 시 어떤 날짜를 입력해도 작성한 오늘 날짜로 게시글이 생성되고 있는데요.

이 현상은 아래와 같이 model 생성 시 auto_now_add=True 를 설정했기 때문에 항상 현재 시간으로 찍히는것인가요?

추측은 되지만 확실하게 알고자 하여 문의드립니다.

dt_created = models.DateTimeField(verbose_name='Data Created', auto_now_add=True)


넹 맞습니당. auto_now_add 나 auto_now 는 위와 같이 입력 값을 반영할 수 없습니당.

시간을 임의로 하시려면 default 파라미터를 이용해보시는게 좋을거에용.
------------------------------------------------------------------------------------------------------------------------

새 글 작성 페이지에서 날짜 위젯이 보이지 않습니다.

from django import forms
from django.forms.widgets import DateInput, SelectDateWidget, SelectMultiple


class PageForm(forms.Form):
    title = forms.CharField(label="제목", max_length=100)
    content = forms.CharField(label="내용", widget=forms.Textarea)
    feeling = forms.CharField(label="감정 상태", max_length=80)
    score = forms.IntegerField(label="감정 점수")
    dt_created = forms.DateField(label="작성일", widget=forms.DateInput)

코드에 저렇게 날짜 위젯을 명시해 줬는데도 일반 CharField처럼 보여요. 몇 가지 더 실험해 봤는데 TextArea와 BooleanField 말고는 거의 TextInput으로만 렌더링 되는 것 같습니다.

안녕하세요,

django를 배우는 수강생입니다.

@Achernar 님께서 이야기 한 내용을 구글링해서 로컬서버에 테스트 해보니 날짜  달력 위젯이 만들어 지네요.

    달력 위젯 만드는 방법

1. forms.py에 NumberInput 을 임포터 해야 합니다.
- from django.forms.widgets import NumberInput 

2. 그리고 위젯을 사용할 곳에 아래 코드처럼 적용 시킵니다.
dt_created = forms.DateTimeField(widget=NumberInput(attrs={'type': 'date'}), label="날짜")

- 달력 위젯 결과 -


※ 구글링 참조 했던 사이트는 입니다. https://ordinarycoders.com/blog/article/using-django-form-fields-and-widgets
--------------------------------------------------------------------------------------------------------------------------------
강의에서 DateField는  Form 을 통해 자동으로 코드가 생성될 때 디폴트 위젯인 달력으로 설정된다고 하셨는데 개발서버 확인 결과 

<input type="text" name="dt_created" required="" id="id_dt_created"> 

이렇게 text 위젯으로 설정된 점을 확인했습니다. 이 과정에서 제가 놓친 부분이 있나요?

DateInput 은 맞는데 이게 기본 위젯이 캘린더형태는 아닙니당. 이건 잘못된 내용 같아용. 제보해봐야겠네용

  -------------------------------------------------------------------------------------------------------------------------------

Django Form Field

Django 폼(Form)을 작성할 때 가장 중요한 부분이 바로 데이터에 맞는 폼 필드를 작성하는 것입니다. Django는 입력 데이터에 따라 사용할 수 있는 여러 내장 폼 필드를 제공하는데, 각각의 폼 필드는 그에 맞는 입력 위젯을 기본으로 가지고 있습니다. 아래는 Django에서 제공하는 몇 가지 필드 목록과 옵션들 입니다.
필드	설명	옵션	기본 위젯
CharField	문자열 입력을 위한 필드입니다.	max_length : 최대 길이 설정 min_length : 최소 길이 설정 strip : 문자열 앞뒤 공백을 제거합니다. (기본값: True) empty_value : 비어 있는 값을 나타낼 값 (기본값: 빈 문자열)	TextInput
EmailField	이메일 입력을 위한 필드입니다.	CharField와 같은 옵션인자를 사용합니다.	EmailInput
IntegerField	정수 입력을 위한 필드입니다.	max_value : 최댓값 설정 min_value : 최솟값 설정	NumberInput
BooleanField	True, False 입력을 위한 필드입니다. (기본적으로 입력을 위해 체크박스가 사용됩니다.)	체크박스가 빈 값일 경우 False로 처리됩니다.	CheckboxInput
ChoiceField	주어진 값 안에서 하나를 선택할 수 있는 형식의 필드입니다.	choices : 선택 항목 들의 목록 인자로 각 선택 목록은 튜플 형식을 사용합니다. 예시: options = [('1', 'male'), ('2', 'female), ('3', 'other')]	Select
MultipleChoiceField	주어진 보기에서 여러개를 선택할 수 있는 형식의 필드입니다.	ChoiceField와 같은 옵션인자를 사용합니다.	SelectMultiple
DateField	날짜 형식을 입력 받는 필드입니다.	input_formats : 날짜의 형식을 지정합니다. (https://docs.djangoproject.com/en/2.2/ref/settings/#std:setting-DATE_INPUT_FORMATS)	DateInput
TimeField	시간 형식을 입력받는 필드입니다.	DateField와 같은 옵션인자를 사용합니다.	TimeInput
DateTimeField	날짜/시간 형식을 입력 받는 필드입니다.	DateField와 같은 옵션인자를 사용합니다.	DateTimeInput

    이 밖에도 데이터 형식에 맞는 몇 가지 내장 필드가 있습니다. 내가 사용할 데이터에 대한 필드가 있는지 궁금할 때는 항상 공식문서를 참고하세요. https://docs.djangoproject.com/en/2.2/ref/forms/fields/#built-in-field-classes
    widget과 관련된 더 많은 내용은 아래 공식문서를 확인하세요. https://docs.djangoproject.com/en/2.2/ref/forms/widgets/

아래는 필드를 정의할 때 사용할 수 있는 필드 옵션들 입니다.
인수	설명
required	필수적으로 입력해야 하는 항목 인지를 결정합니다. 기본값은 True이며 False일 경우 비워두는 것을 허용합니다.
label	해당 필드의 label 항목에 적힐 이름을 지정합니다. 만약 지정하지 않을 경우 폼 필드를 지정한 변수명의 첫 글자를 대문자로, 밑줄(_)이 있다면 띄어쓰기로 변경하여 label 값으로 사용합니다.
label_suffix	기본적으로 label 다음 콜론(:)이 붙어서 표시되는데 이 값을 변경합니다.
initial	해당 필드에 초기값을 줄 때 사용합니다.
widget	해당 필드가 사용할 사용자 입력 UI, 즉 위젯을 지정합니다. 기본적으로 각 데이터 항목에 맞는 기본 위젯이 설정되어 있습니다.
help_text	입력에 도움이 되는 문자열을 입력 필드 밑에 표시합니다.
validators	유효성 검증을 위한 검증 목록을 리스트 형태로 작성합니다.
disabled	필드의 편집 가능 여부를 결정합니다. 기본 값은 False 이며 True일 경우 해당 필드가 보이지만 편집할 수 없습니다.

    label

# forms.py
from django import forms

class UserForm(forms.Form):
    name = forms.CharField()
    age = forms.IntegerField(label='Your age')

<!-- html -->
<label for="id_name">Name:</label> 
<input type="text" name="name" required id="id_name">
<label for="id_age">Your age:</label>
<input type="number" name="age" required id="id_age">

    label_suffix

# forms.py
from django import forms

class UserForm(forms.Form):
    name = forms.CharField()
    age = forms.IntegerField(label_suffix='=')

<!-- html -->
<label for="id_name">Name:</label>
<input type="text" name="name" required id="id_name">
<label for="id_age">Age=</label>
<input type="number" name="age" required id="id_age">

    help_text

# forms.py
from django import forms

class UserForm(forms.Form):
    name = forms.CharField(help_text='한글 이름을 작성해주세요.')
    age = forms.IntegerField()

<!-- html -->
<label for="id_name">Name:</label>
<input type="text" name="name" required id="id_name">
<span class="helptext">한글 이름을 작성해주세요.</span>
<label for="id_age">Age:</label>
<input type="number" name="age" required id="id_age">

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4139&directory=Untitled.png&name=Untitled.png


더 많은 필드 옵션이 궁금하다면 아래 공식 문서를 참고하세요.
https://docs.djangoproject.com/en/2.2/ref/forms/fields/#core-field-arguments
--------------------------------------------------------------------------------------------------------------------------------
폼을 더 간단하게, 모델 폼! (Model Form)

앞서 우리가 작성한 PostForm 클래스를 보면 Post 모델과 형태가 비슷하다 코드를 봐도 중복되는 부분들도 좀 보인다 이렇게 왭 서비스에서의 폼은 데이터베이스 기반 즉 모델을 기반으로 만드는 경우가 많다
forms.py
from django import forms 

class PostForm(forms.Form):
    title = forms.CharField(max_length=50, label='제목')
    content = forms.CharField(label='내용', widget=forms.Textarea)
    
models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=50)
    content = models.TextField()
    dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True)
    dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

    def __str__(self):
        return self.title

유저로부터 데이터를 입력받아 데이터베이스에 저장하는 등의 로직이 많기 때문인데 이번시간에 배울 ModelForm은 장고의 강력한 폼 기능중 하나로 우리가 작성한 모델을 기반으로 해서 자동으로 폼을 생성해준다
일일이 폼을 작성하는것을 django form 클래스를 이용해서 간편하게 처리했는데 이제 이 form 클래스를 작성하는것 마저 ModelForm을 이용해서 더 간편하게 하는것이다 앞으로 우리가 만드는 대부분의 djnago 프로젝트들은
이번 시간에 배우는 ModelForm을 사용하게 될것이다

자 그러면 ModelForm을 사용해보자 먼저 ModelForm 을 상속하게 하자 -> class PostForm(forms.ModelForm):
다음에 우리가 사용할 모델을 불러오자 -> from .models import Post 그리고 아래와 같이 써주자

class PostForm(forms.ModelForm):
    class Meta:
        model = Post

안쪽의 Meta 클래스는 PostForm이라는 클래스를 만들 때 적용할 여러가지를 넣어주는 클래스다 이렇게 생각하면 된다 그리고 model = Post 이렇게 적어주면 Post모델을 보고 장고가 폼을 생성하게 되는데 이 Post 모델 여러 필드가 있었지?
그 중에서 어떤 필드를 폼으로 만들것인지를 명시해 주기 위해서 fields라는 변수에 리스트 형태로 Post 모델에 필더를 넣어주면 된다 
->
class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields =['title', 'content']

dt_created와 dt_modified 는 폼으로 입력받는 것이 아니라 자동으로 생성되니까 넣어줄 필요가 없다 자 그런데 지금은 두개만 적어줬지만 모든 필드를 폼으로 만들고 싶은데 모델의 필드가 많다면 지금처럼 하나하나 적기 어렵다 그러면은 
fields = '__all__'  이런식으로 적어주면 모든 필드가 적용된다 참고로 알아두자 
다시 돌아와서 폼 작성은 이것으로 끝이다 각각의 폼 필드가 어떤 형식으로 작성되어야하는지는 모델에서 정의한 필드를 참고하여 장고가 자동으로 폼을 생성하게 해주면된다 

그럼 vuews.py로 가서 

def post_create(request):
    if request.method == 'POST':
        title = request.POST['title']
        content = request.POST['content']
        new_post = Post(
            title = title,
            content = content
        )
        new_post.save()
        return redirect('post-detail', post_id=new_post.id)
    else:
        post_form = PostForm()
        return render(request, "posts/post_form.html", {'form' : post_form})

이 코드의 if 절 안을 ModelForm을 이용해 더 간단하게 고쳐보자

def post_create(request):
    if request.method == 'POST':
        post_form = PostForm(request.POST)
        new_post = post_form.save()
        
        return redirect('post-detail', post_id=new_post.id)
    else:
        post_form = PostForm()
        return render(request, "posts/post_form.html", {'form' : post_form})

자 코드에 대해서 간단하게 설명하자면 post_form = PostForm(request.Post) 이런식으로 먼저 폼과 데이터를 바인딩해준다 다음에 이 바인딩 된 내용을 new_post = post_form.save() 이렇게 save해주면 데이터베이스에 저장할 수 있다
모델 폼이 가지고 있는 이 save 함수는 바운드폼으로부터 가져온 데이터로 모델 인스턴스를 만들고 인스턴스를 데이터베이스에 처리하는 과정을 진행해준다 근데 이건 좀 복잡하니까 그냥 save를 호출하면 데이터베이스에 데이터가 저장된다
이렇게만 이해해도록 하자 그 다음에 저장을 하고 코드가 잘 작동하는지 확인하자 -> 개발서버 열고 글쓰기로 가서 글 서보자
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

실습과제
더 간단한 작성 페이지

아래를 참고해서 모델 폼(Model Form)을 사용해 감정 일기 작성 페이지를 구현해 주세요.

    forms.py에 작성되어 있는 PageForm을 모두 지우고 forms.ModelForm을 상속 받아 PageForm을 작성해 주세요.

    Page 모델을 import 하고 아래를 참고해서 PageForm을 작성해 주세요.

    # PageForm 안쪽에 들어갈 class
    class Meta:
        model = <사용 할 모델>
        fields = ['사용 할 필드']

    views.py로 이동해서 아래를 참고해 page_create 뷰를 수정해 주세요.

    def page_create(request):
        if request.method == 'POST':
            # 이곳을 수정합니다.
            return redirect ...

    먼저 request로부터 데이터를 가져와서 PageForm과 바인딩 해주세요.

    form = 바인딩 폼

    form을 이용해 데이터를 저장하고, 저장한 데이터를 new_page라는 변수로 받습니다.

    new_page = form을 이용한 저장 로직

    개발 서버를 켜고 일기 작성 페이지로 들어가 새 글을 작성한 뒤 정상적으로 상세 일기 보기 페이지로 이동하는지 확인해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4140&directory=Untitled.png&name=Untitled.png

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4140&directory=Untitled%201.png&name=Untitled+1.png

과제 해설close solution tab

    지금 작성된 forms.py의 PageForm을 모델 폼(Model Form)으로 바꾸는 과정입니다. 먼저 forms.ModelForm을 상속받아 PageForm을 정의합니다.

    from django import forms

    class PageForm(forms.ModelForm):

    모델 폼을 사용하는 것의 장점은 폼 필드를 각각 정의해 주지 않아도 모델의 필드를 보고 자동으로 장고가 유추해서 폼 필드를 만들어 준다는 것입니다. 이를 위해 Meta 클래스를 이용해 사용할 모델과 입력받을 모델 필드를 명시해 주어야 합니다.

    from django import forms
    from .models import Page # 사용할 모델을 가져옵니다.

    class PageForm(forms.ModelForm):

        class Meta:
            model = Page # 모델 폼에서 사용할 모델과 필드를 명시합니다.
            fields = ['title', 'content', 'feeling', 'score', 'dt_created']

    PageForm을 모델 폼으로 변경 했으므로 page_create 뷰의 로직도 수정해 주어야 합니다. POST 방식일 때의 로직에서 기존에는 request.POST로 부터 입력된 데이터를 하나씩 가져 왔지만 이제는 ModelForm을 사용 하기 때문에 Model과 Form이 서로 다루게 될 데이터의 형식을 알고 있는 상태 이므로 아래와 같이 바로 바인딩 폼을 만들 수 있습니다. 그 후 바인딩 폼을 이용해 데이터를 저장하고 이때 반환 되는 데이터 모델을 new_page에 받아서 redirect의 page_id 값으로 사용합니다.

    def page_create(request):
        if request.method == 'POST':
            form = PageForm(request.POST) # 입력된 데이터와 폼을 합쳐서 바인딩 폼을 만듭니다.
            new_page = form.save() # 데이터 저장 및 생성된 데이터 모델 반환
            return redirect('page-detail', page_id=new_page.id)
            else:
                ...

    # 이전 코드
    def page_create(request):
        if request.method == 'POST':
            new_page = Page( # 아래 부분이 ModelForm을 사용하면 간단해 집니다.
                title=request.POST['title'],
                content=request.POST['content'],
                feeling=request.POST['feeling'],
                score=request.POST['score'],
                dt_created=request.POST['dt_created']
            )
            new_page.save() # 여기서는 Page 모델을 이용한 저장로직
            return redirect('page-detail', page_id=new_page.id)
            else:
                ...

    개발 서버를 켜고 일기 작성 페이지로 간 다음 정상적으로 동작하는지 확인해 주세요.

-------------------------------------------------------------------------------------------------------------------------------

데이터 유효성 검사란?
우리가 원하는 규격이 맞는지 확인하는 과정 예를들어 이름을 입력하는 곳에 숫자를 입력하거나 꼭 필요한 데이터인데 입력하지 않거나 들어가서는 안되는 특수 문자나 문자열이 들어가는 등이 데이터가 유효하지 않은 경우다
그렇기 때문에 데이터가 항상 유효하지 않다는 가정을 하고 데이터의 유효성을 체크하고 유효하지 않다면 다시 입력하게 하거나 유효한 형식으로 만드는 과정을 생각해야한다
이러한 유효성 검증을 우리가 자연스럽게 사용한 적이 있는데 바로 모델을 정의할 때다 models.py를 보면 각각의 필드를 우리가 원하는 데이터 형식에 맞도록 문자열은 CharField 날짜는 DateTimeField 등을 사용하고 title 같은것은
최대 길이 까지 정해주었다 이런 부분들이 바로 데이터 유효성 검증에 해당한다

유효성 검증 (Validation)
장고에는 이러한 Validation을 처리하는 다양한 방법이 있다 이어지는 레슨에서 구현해볼 검증은 다음과 같다
1. 모든 항목은 빈칸 없이 반드시 채워져야한다
2. 제목은 50자 까지만 작성 가능하다
3. 다른 제목과 중복될 수 없다
4. 내용은 10자 이상이어야한다
5. 내용에는 '#'과 '@'을 쓸 수 없다
-------------------------------------------------------------------------------------------------------------

Field 인자로 유효성 검증하기

필드에서 유효성 검증을 하는 방법은 두가지가 있다
1. Field를 정의할 때 필요한 옵션 인자로 주기
2. 따로 validator를 추가하기

이 두가지를 이용해서 필드를 잘 정의하면 유효성 검증의 많은 부분을 처리할 수 있다 이번에는 둘 중에서 장고의 내장 필드 옵션을 이용해서 유효성 검증을 해보자

Field 
필드라고 하면 우리에겐 두가지가 있다 모델을 정의할 때 사용하는 모델 필드와 폼을 정의할 때 사용하는 폼 필드 이 두가지 경우 모두 동의하게 유효성 검증을 할 수 있고 우리는 지금 모델폼을 이용하고 있으므로 모델의 유효성 
검사를 추가하면 된다 그러면 자동으로 모델을 기반으로 폼이 생성되므로 유효성 검증이 한번에 이루어지게 된다

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=50)
    content = models.TextField()
    dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True)
    dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

    def __str__(self):
        return self.title
        
models.py를 가서 각각의 필드마다 유효성 검증을 추가해보면 된다 먼저 해볼것은 장고에서 기본적으로 제공하는 옵션 인자를 이용하는 방법이다  우리가 구현해야하는 유효성 검증 중에 제목과 내용은 폼을 빈칸으로 둘 수 없고
반드시 내용을 입력해야한다 여기 각각 모델필드의 옵션 인자중에 blank를 False 로 두면 된다 이 blank는 모든 필드에 기본적으로 있는 옵션 인자로 폼의 빈칸을 허용할지를 결정한다 기본값은 False이다 
그러니까 우리의 경우 따로 따로 설정해줄 필요가 없다 빈칸을 허용하고 싶다면 그냥 True 로 두면 된다 이러한 기본 옵션 중에 null 옵션도 있다 null은 데이터에 빈 값을 null로 저장하는 것을 허용할지 여부를 결정한다
null이 True라면 빈 값이 넘어왔을 때 null로 변환해서 데이터베이스에 저장된다 
이러한 blank 옵션을 문자열 기반 필드에서 사용할 때는 주의를 해야하는데 비어있다라는 뜻을 나타내는 것이 빈 값과 null 두가지가 있기 때문이다 하나의 시스템에서는 비어있는 것을 의미하는 값은 하나가 되야한다
장고 표준에서는 문자열 기반 필드에서 빈 문자열 "" 을 비어 있는 값으로 하는 것을 권장한다 그래서 문자열 기반 필드에서는 blank 옵션을 True로 하면 빈 문자열이 저장되도록 한다 따라서 자연스럽게 null을 True로 하는 옵션은
문자열 기반 필드에서는 권장되지 않는다

자 다음으로 제목은 50자 제한이 있는데 이렇게 되면 50자 이상 입려을 하려해도 더이상 입력이 되지 않는다
다 다음으로 모든 제목은 중복되지 않아야하는데 이 때 사용할 수 있는 옵션으로는 unique 옵션이 있다 unique 옵션은 기본적으로 False 로 설정되어 있는데 True 로 하면 데이터베이스에는 같은 형식의 데이터는 저장할 수 없게 된다
만약 같은 형식의 데이터를 저장하려고 하면 유효하지 않다는 에러를 내게 되는데 이 부분은 뒤에서 자세하게 배운다     title = models.CharField(max_length=50, unique=True) 이렇게 하면 이제 같은 제목의 데이터는 저장할 수 없다 

자 이제 views.py로 가보자

def post_create(request):
    if request.method == 'POST':
        post_form = PostForm(request.POST)
        new_post = post_form.save()

        return redirect('post-detail', post_id=new_post.id)
    else:
        post_form = PostForm()
        return render(request, "posts/post_form.html", {'form' : post_form})

여기 POST 일 떄 즉 유저로부터 데이터를 입력받을 때 바로 데이터베이스에 데이터를 저장하게 되어있는데 이렇게 데이터의 유효성을 검증하지 않고 바로 데이터를 사용하고 저장하는것은 위험하다 이 부분을 수정해서 
데이터 유효성 검증을 해 통과하면 데이터베이스에 저장을 하고 아니면 다시 입력하도록 해주자   if post_form.is_valid():  if 문을 이용한다 is_valid() 메소드는 post_form의 데이터가 유효한지 체크한다
유효하면 데이터를 저장하고 리디렉하게하자 데이터가 유효하지 않을 때도 구현해보자 else -> return render(request, "posts/post_form.html", {'form' : post_form}) 이렇게 되면 유효성을 통과하지 못한 
폼을 다시 템플릿에 전달하게 되고 이 때 유효성 검증을 통과 못한 에러메세지가 기존의 데이터와 함께 전달된다 유저는 입력했던 폼에 있는 데이터를 바탕으로 다시 입력하게 된다
->
def post_create(request):
    if request.method == 'POST':
        post_form = PostForm(request.POST)
        if post_form.is_valid():
            new_post = post_form.save()
            return redirect('post-detail', post_id=new_post.id)
        else:
            return render(request, "posts/post_form.html", {'form' : post_form})

    else:
        post_form = PostForm()
        return render(request, "posts/post_form.html", {'form' : post_form})

다음과 같이 줄일 수 있다
->
def post_create(request):
    if request.method == 'POST':
        post_form = PostForm(request.POST)
        if post_form.is_valid():
            new_post = post_form.save()
            return redirect('post-detail', post_id=new_post.id)
    else:
        post_form = PostForm()
    return render(request, "posts/post_form.html", {'form' : post_form})
    

자 이제 제목이 중복되는 글을 한번 써보자 -> 에러메세지가 영어로 나온다 -> 이 에러메세지를 바꾸고 싶다면? -> models.py에 가서 바꿔주자!
title = models.CharField(max_length=50, unique=True) -> title = models.CharField(max_length=50, unique=True, error_messages = {'unique' : "제목이 중복됩니다!"})
-> unique 라는 에러가 생기면 사전형 key인 unique의 value 인 에러 메시지가 나간다 이러한 key 값에는 지금처럼 장고 내장 옵션 인자를 에러코드로 사용할 수 있고 커스텀 에러코드를 입력할 수 도 있다
다음 레슨에는 여러가지 validator를 추가하는 방법을 배워보자 
-----------------------------------------------------------------------------------------------------------------------------------------------
    
만약 데이터가 보다 복잡한 유효성을 요구한다면? 이 때 사용할 수 있는 것이 바로 Validator 이다 Validator 는 임의의 값을 받아서 내부의 기준을 충족하지 않으면 ValidatorError를 발생시키는 함수이다
Validator는 하나의 필드에 종속되지 않고 여러 필드에서 사용할 수 있으며 장고에서 기본적으로 제공하는 built-in Validator를 사용하서나 필요하다면 Validator를 직접 구현할 수 있다 먼저 장고에서
제공하는 Validator를 사용해보겠다 Built-in Validator는 여러 종류가 있는데 우리가 구현하는 유효성 중 하나인 내용은 최소 10글자 이상이어야 한다는 유효성을 구현해보자 사실 모든 validator를 외우고 있는것은 
말이 안되기 때문에 필요할 때마다 찾아서 사용한다 -> 웹 브라우저로 가서 django built-in validators 이렇게 검색해보자 장고 공식 문서에 들어가자 https://docs.djangoproject.com/en/4.0/ref/validators/
여기에 validator들이 쫙 있는데 지금 원하는건 길이에 관한거니까 MaxLengthValidator 랑 MinLengthValidator 를 보자 

MinValueValidator¶
class MinValueValidator(limit_value, message=None)¶
Raises a ValidationError with a code of 'min_value' if value is less than limit_value, which may be a callable.

여기 MinValueValidator를 보면 최소 길이에 대한 limit_value와 유효성 검증을 실패했을 때 보여주는 에러 메세지 message를 적어줄 수 있다
자 그러면 이걸 어떻게 사용할까? 이거는 import를 해야한다 장고 공식 문서 페이지에서 찾아보면  django.core.validators 여기서 import 하라고 나와있다
자 그럼 한번 해보자 models.py에서 import 해준다 from django.core.validators import MinLengthValidator
자 이제 validator를 사용하면 되는데 어디에 적용할까? 각각의 필드 안에 Validator 라는 항목이 있다 여기에 적용할 validator를 적어주면 된다 한번 해보자 먼저 여기 content에다 하자
content = models.TextField() -> content = models.TextField(validators = [MinLengthValidator(10, "10자 이상 쓰세요")])
개발 서버 켜고 에러메세지 잘 뜨나 확인해보자 잘뜬다 자 이제 그러면 #과 @을 쓸 수 없게 하는 유효성 검증도 추가해보자 이 부분은 직접 validator를 만들면서 해결해보자
posts 앱에 validators.py라는 파일을 하나 더 만들어주자 validator는 인자로 넘어오는 밸류를 검증하는 로직을 수행하다가 유효성 검증이 실패했을 때 ValidationError를 발생시켜주면 된다
그러면 장고에서 지원하는 ValidationError 객체를 가져와보자 from django.core.exceptions import ValidationError 이렇게 해주자 이 ValidationError는 장고에서 제공하는 여러 에러중 하나로
유효성 검증 실패를 의미하는 에러이다 이 ValidationError 를 발생시키면 장고 내부적으로 에러인데 유효성 검증에 실패했구나 이런식으로 이해하고 그거에 맞는 처리 로직을 수행한다 자 그러면 
함수를 하나 써보자
->
def validate_symbol(value):
    if "@" in value or "#" in value:
        raise ValidationError('"@"와 "#"는 포함될 수 없습니다.', code="symbol_err")

에러를 발생시키는 raise 문을 사용하고 ValidationError 인수로 에러문구룰 적어주구 에러코드는 symbol_err 로 임의의로 설정해준다 여러가지 에러들 중에 이 에러를 구분할 수 있도록 임의의 코드를 부여해준거다
자 이제 models.py로 가서 작성했던 validator를 가져와보자 from .validators import validate_symbol 그리고 content 를 보자 content = models.TextField(validators = [MinLengthValidator(10, "10자 이상 쓰세요")])
여기 validators 옵션의 리스트 안에 넣으면 된다 -> content = models.TextField(validators = [MinLengthValidator(10, "10자 이상 쓰세요"), validate_symbol])
자 이제 개발서버를 실행하고 테스트 해보자 잘 나오는가? 잘나온다 자 이렇게 배운 모델 유효성 검증을 사용하면 모델폼을 사용할 경우 대부분의 유효성 검증을 커버할 수 있다 다음 시간에는 폼에서 할 수 있는 유효성 검증을 배워보자

파이썬의 raise문에 대해 더 알아보고 싶다면 아래의 공식 문서를 참고해주세요 :)
파이썬 raise문 공식 문서 바로가기 https://docs.python.org/ko/3/tutorial/errors.html#raising-exceptions

--------------------------------------------------------------------------------------------------------------------------------

데이터 모델이 변경되면 migration을 해주어야 한다고 알고 있었는데

해당 수업에서 models.py에 validator들을 추가 해주었지만 migrate진행을 하지 않고도 잘 진행 되었습니다.

때문에 두가지 질문이 있습니다.

1. models.py에 추가한 validator들은 데이터베이스에 제약조건을 추가하는 용도가 아닌걸까요?

 (작성한 validator들이 sql문으로 변환되어 데이터베이스에 입력되는 용도가 아닌걸까요?)

 

2. 만약 1의 용도가 아니라면 models.py에 입력한 validator들은

  views.py의 .is_valid의 함수를 작동시키기 위함일까요?

  (데이터베이스에서가 아닌 파이썬에서 유효성 검증을 진행하는 걸까요?) 
  

is_valid() 메서드가 실행되는 순서입니다.

form이 여러개의 데이터로 구성되어 있으면, is_valid()메서드는 full_clean()메서드를 실행합니다.

full_clean() 메서드는 아래의 순서로 form필드를 검사하는데요,

    to_python 메서드로 파이썬 코드로 변환합니다. 실패하면 ValidationError가 발생합니다.
    커스터마이징한 validator들과, 필드에 명시된 validator들을 검사합니다. 실패하면 ValidationError가 발생합니다.
    form에 clean_으로 시작하는 메서드가 있다면,  실행합니다.

full_clean()메서드는 마지막으로 clean메서드를 실행합니다. clean메서드는 cleaned_data 딕셔너리를 리턴하구요.
------------------------------------------------------------------------------------------------------------------------------------

실습과제
100XP
오늘 하루는 유효했나요?

감정 일기에 다음과 같은 유효성 검사를 추가하려고 합니다. diary 앱 디렉토리 안의 validators.py에 유효성 검사기(validator)를 작성해 주세요.

1. '제목'과 '내용'에는 '#'이 들어갈 수 없습니다.
2. '감정 상태' 에는 숫자가 들어갈 수 없습니다.
3. '감정 점수'는 0부터 10사이의 숫자만 들어갈 수 있습니다.

    유효성 검사 함수는 유효성 검사에 실패했을 경우 ValidationError를 발생 시켜야 합니다.

    from django.core.exceptions import ValidationError

    ValidationError는 첫번째 파라미터로 에러 메세지를 받습니다.

    ValidationError('error message')

    먼저 '#'이 들어있는 지를 검증하는 validate_no_hash 함수를 작성해 주세요.

    def validate_no_hash(value):
        ...
        raise ValidationError(...)

    다음으로는 숫자가 들어있는 지를 검증하는 validate_no_numbers 함수를 작성해 주세요.

    .isdigit() 함수는 문자가 숫자 값인지 아닌지를 판단해서
    그 결과를 True, False로 돌려주는 함수입니다.

    for ch in value: # 입력된 문자열을 하나씩 반복하면서
        # 숫자가 있는지를 체크하면 되겠죠?

    마지막으로 입력된 값이 0부터 10사이의 숫자 인지를 검증하는 validate_score 함수를 작성해 주세요.

    모델 폼을 사용하고 있으므로 models.py로 가서 아래를 참고하여 각 필드 별 알맞은 유효성을 추가해 주세요.

    1. '제목'과 '내용'에는 '#'이 들어갈 수 없습니다.
    2. '감정 상태' 에는 '#'과 숫자가 들어갈 수 없습니다.
    3. '감정 점수'는 0부터 10사이의 숫자만 들어갈 수 있습니다.

    example_field = models.CharField(validators=[validator ...])

    views.py로 가서 아래를 참고하여 데이터가 유효할 때만 저장 로직을 수행하도록 수정해 주세요.

    # 데이터와 폼이 합쳐진 바운드폼으로 데이터가 유효한지 여부를 체크할 수 있습니다.
    form.is_valid()

    데이터가 유효하지 않을 경우에는 입력된 폼 데이터를 다시 page_form 템플릿으로 전달하여 비어 있지 않은 상태에서 데이터를 수정할 수 있도록 작성해 주세요.

    개발 서버를 켜고 각각의 유효성 검증이 잘 동작 하는지 체크해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4143&directory=Untitled.png&name=Untitled.png

과제 해설close solution tab

    diary/validators.py에 유효성 검사를 위한 함수를 작성합니다.
        유효성 검사는 조건을 만족하지 못했을 경우 ValidationError를 발생시키면 됩니다.
        먼저 ValidationError를 import 합니다.

    # validators.py

    from django.core.exceptions import ValidationError

    입력된 값에 '#'이 포함되어 있는지를 검증하는 validate_no_hash 함수를 작성합니다.
        함수를 정의하고 파라미터로 검증을 수행할 값을 받습니다.
        그 후 만약 해당 값에 '#'이 들어 있다면 raise 문을 이용해서 ValidationError를 내도록 합니다.
        이때 에러 메시지를 함께 적어 줄 수 있습니다.

    from django.core.exceptions import ValidationError

    def validate_no_hash(value):
        if '#' in value:
            raise ValidationError('# 은 포함될 수 없습니다.')

    다음으로 입력된 값에 숫자가 들어 있는지를 검증하는 validate_no_numbers 함수를 작성합니다.
        입력된 값을 하나씩 반복하면서 isdigit()을 이용해 숫자 인지 여부를 체크합니다.
        만약 해당 값이 숫자라면 ValidationError를 내도록 합니다.

    from django.core.exceptions import ValidationError

    ...

    def validate_no_numbers(value):
        for ch in value:
            if ch.isdigit():
                raise ValidationError('숫자는 들어갈 수 없습니다.')

    마지막으로 입력된 값이 0부터 10사이의 숫자 인지를 검증하는 validate_score 함수를 작성합니다.

    from django.core.exceptions import ValidationError

    ...

    def validate_score(value):
        if value < 0 or value > 10:
            raise ValidationError('0부터 10사이의 숫자만 입력 가능합니다.')

    이제 작성한 validator들을 적용 시켜 주면 됩니다.
        우리는 현재 모델 폼을 사용하고 있으므로 모델 필드에 유효성 검증을 추가 해주면 됩니다.
        models.py로 가서 먼저 우리가 작성한 validator를 가져옵니다.

    from django.db import models
    from .validators import validate_no_hash, validate_no_numbers, validate_score

        각각의 필드에 맞는 유효성을 validators 파라미터로 전달합니다.

    from django.db import models
    from .validators import validate_no_hash, validate_no_numbers, validate_score

    # Create your models here.
    class Page(models.Model):
        title = models.CharField(max_length=100, validators=[validate_no_hash])
        content = models.TextField(validators=[validate_no_hash])
        feeling = models.CharField(max_length=80, validators=[validate_no_hash, validate_no_numbers])
        score = models.IntegerField(validators=[validate_score])
        dt_created = models.DateField()

        def __str__(self):
            return self.title

    이제 views.py로 가서 입력된 데이터가 유효성 검증을 통과 했을 때만 저장 되도록 로직을 수정합니다.

    def page_create(request):
        if request.method == 'POST':
            form = PageForm(request.POST)
            if form.is_valid(): # 데이터가 유효한 경우에만
                new_page = form.save() # 저장 로직을 수행하고
                return redirect('page-detail', page_id=new_page.id) # 새 페이지로 갑니다.
        else:
                ...

    그리고 만약 데이터가 유효하지 않다면 어떻게 해야 할까요? 다시 데이터를 입력하도록 하면 됩니다.
        데이터가 유효하지 않다면 page_form 템플릿에 바인딩 폼을 전달하여 데이터가 있는 상태로 다시 입력하도록 결과로 돌려줍니다.

    def page_create(request):
        if request.method == 'POST':
            form = PageForm(request.POST) # 이 form은 입력된 데이터가 들어있는 바인딩 폼입니다.
            if form.is_valid():
                new_page = form.save()
                return redirect('page-detail', page_id=new_page.id)
            else: # 데이터가 유효하지 않다면
                return render(request, 'diary/page_form.html', {'form': form})
        else:
            form = PageForm() # 이 form은 비어있는 폼 입니다.
            return render(request, 'diary/page_form.html', {'form': form})

        위와 같은 코드는 아래처럼 다시 적을 수 있습니다.
        데이터가 유효하지 않을 때의 else를 지우고 중복되는 return render (...)를 하나로 수행하도록 작성했습니다.
        이렇게 하면 요청이 POST 방식이라면 입력된 데이터가 채워진 form을, GET 방식이라면 비어있는 form을 갖게 됩니다.

    def page_create(request):
        if request.method == 'POST':
            form = PageForm(request.POST)
            if form.is_valid():
                new_page = form.save()
                return redirect('page-detail', page_id=new_page.id)
        else:
            form = PageForm()
        return render(request, 'diary/page_form.html', {'form': form})

    개발 서버를 켜고 각각의 유효성 검증이 잘 동작 하는지 확인해 주세요.

----------------------------------------------------------------------------------------------------------------------------------------
null = True 로 설정할 시 migration

title의 blank 에 True 값을 그리고 null에 True 값을 설정한 후 개발서버에서 제목이 빈칸인 게시물을 전송했더니 

NOT NULL constraint failed

위와 같은 에러가 났습니다 

개발서버를 끄고 migration 을 생성, 적용한 후 다시 개발서버를 열어 제목이 빈칸인 게시물을 올렸더니 제목이 None 인 게시물이 잘 올라갔습니다

여기서 처음에 에러가 난 이유와 마이그레이션 생성,적용 했더니 에러가 없어진 이유가 무엇인가요?


1.
migration 하기 전 상태를 알면 좋을텐데,

blank= True 와 null=True 를 migration 을 안하셨다면 해야 반영되는게 맞을 것입니당.

원래 기본값은 False 로 주어지게 되니까용

2.
Db 혹은 객체화 코드 부분, 또는 어댑터 부분 전부 살펴보시는 게 좋지 않을까요.

스키마에 따라서 코드가 재생성되거나, 코드에 따라서 스키마를 형성할 것 같아 마이그레이션 시에 수동으로 고쳐야하는 점이 있을 것 같아요
---------------------------------------------------------------------------------------------------------------------------
제목이나 내용을 빈칸으로 남기고 전송 버튼을 누를 때와 중복되는 제목일 때 전송 버튼을 누르는 경우

제목이 중복일 때 전송 버튼을 누르면 바운드 폼이 뷰로 전달되어 is_valid를 통해 유효성 검사를 하게 되는데 

제목이나 내용을 빈칸으로 남기고 전송 버튼을 누를 때는 바운드된 폼이 뷰로 전달 되지 않나요?

def post_create(request):

    if request.method == 'POST':

        post_form = PostForm(request.POST)

        if post_form.is_valid():

            new_post = post_form.save()

            return redirect('post-detail', post_id=new_post.id)

    else:

        post_form = PostForm()

    return render(request, "posts/post_form.html", {'form' : post_form})

위의 코드를 

def post_create(request):

    if request.method == 'POST':

        post_form = PostForm(request.POST)

        if post_form.is_valid():

            new_post = post_form.save()

            return redirect('post-detail', post_id=new_post.id)

    else:

        pass

    post_form = PostForm()

    return render(request, "posts/post_form.html", {'form' : post_form})

다음과 같이 고치고 내용에는 텍스트를 입력하고 제목은 빈칸으로 놔둔채로 전송버튼을 누르면 "이 항목을 입력세요"라는 툴팁 같은게 뜨고 (에러메시지와는 다른)

제목이 빈칸이고 내용은 채워져 있는 폼은 그대로 유지됩니다 

만약 이 경우 바운드폼이 뷰로 전달된다면 제가 고친 post_create 뷰대로 전송 버튼 누른 후 모든 항목이 빈칸은 새로운 폼을 받을 텐데

제목이 비었고 내용은 채워져있는 폼이 그대로 있는거 보니 바운드폼이 아예 뷰로 전달되지 않은거 같아요!


예리하신 지적입니당~!

위와 같은 경우엔 전송을 눌러도 뷰로 전달되지 않습니당.

처음 posts/new 페이지에 접근할 때는 GET 요청이 들어가고,

이에 따라 해당 로직이 실행되지만용.

---------------------------------------------------------------------------------------------------------------------------------------

폼(form)에서 유효성 검증하기

모델에 썼던 필드 옵션과 발리데이터들은 폼 필드에서도 그대로 쓸 수 있다 이전까지 연습에서는 모델폼을 사용해서 폼 필드가 없었지만 모델을 쓰지 않는 일반 폼의 경우 forms.py에 각각의 폼 필드를 작성해야하고
그 때 우리가 배운 필드 옵션과 validator들을 적어줄 수 있다 우리의 경우에도 모델에 연관되지 않은 데이터를 입력받아야 할 때는 추가적으로 폼 필드를 만들 수 있다 자 해보자

from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields =['title', 'content']
        
다음과 같이 추가해주자 

from django import forms
from .models import Post
from .validators import validate_symbol

class PostForm(forms.ModelForm):
    memo = forms.CharField(max_length=50, validators=[validate_symbol])
    class Meta:
        model = Post
        fields =['title', 'content']

개발 서버를 켜고 들어가면 Memo란이 생겼다
이 Memo 필드는 예시로 든것이니 일단 지워주자 자 이렇게 필드를 정의할 때 유효성 검사를 작성하는 것 이외에 다른 방법으로 유효성을 검사할 수 있는데 바로 clean_필드네임 을 사용하는것이다 
자 한번 해보자

from django import forms
from .models import Post
from .validators import validate_symbol

class PostForm(forms.ModelForm):
    # memo = forms.CharField(max_length=50, validators=[validate_symbol])
    class Meta:
        model = Post
        fields =['title', 'content']
    
    def clean_title(self):
        title = self.cleaned_data["title"]

Meta 클래스 아래쪽에 함수를 정의해준다 clean_ 하고 유효성 검사를 할 필드명을 적는다 (title) 이제 유효성 검사를 할 데이터를 가져와야한다 title이라는 변수에다가 self.cleaned_data 이렇게 해주고 안에다 'title'
이렇게 넣어준다 모든 Form 클래스는 기본적으로 cleaned_data걸 가지고 있는데 이 cleaned_data 안에는 폼필드를 정의할 때 넣어준 유효성 검증을 통과한 데이터가 들어가있다 만약 폼필드를 사용하지 않았다면 유저가 입력한
데이터가 그대로 넘어오게 된다 우리는 모델 필드에 유효성 검증을 넣어줬기 때문에 여기서 가져온 cleaned_data['title'] 에는 유효성 검증이 이루어지지 않은 상태라는 것이다 자 이상태에서 title에다가 유효성 검증을 추가하면 된다
자 한번 해보자 제목에 "*"가 있으면 안되는 유효성을 추가해보자

from django import forms
from .models import Post
from .validators import validate_symbol
from django.core.exceptions import ValidationError

class PostForm(forms.ModelForm):
    # memo = forms.CharField(max_length=50, validators=[validate_symbol])
    class Meta:
        model = Post
        fields =['title', 'content']
    
    def clean_title(self):
        title = self.cleaned_data["title"]
        if "*" in title:
            raise ValidationError("*는 포함될 수 없습니다")
        return title

자 이러한 clean_필드 가 Validator 와 다른 점은 clean_필드 는 하나의 필드에 대해서만 검증아 가능하며 유효성 검증 에러를 내는것과는 상관 없이 항상 이런식으로 return title 해서 cleaned_data에서 가져온
데이터를 리턴해줘야 한다 그에 반해 validator는 한번 정의하면 모델과 폼에서 모두 사용이 가능하고 여러 필드에서 사용이 가능하다 자 여기 까지 적어줬으면 저장을 한 다음에 개발서버를 켜봐라 
제목에 *을 입력하고 전송으로 누르면 에러문구가 뜬다

자 보면 유효성 추가할 수 있는 단계가 여러군데 있다 (models.py 나 forms.py) 오늘 배운 단계만 생각해보면 폼 유효성 검증을 하고 나서 모델 유효성을 검증한다 그리고 폼에 폼 필드가 정의되어 있다면 각각의
필드에 정의에 사용된 유효성 검증을 먼저하고 그 다음에 clean_필드 를 이용해서 유효성 검증을 하게된다 내가 처리하는 데이터를 어디서 어떤 유효성 검증을 해서 사용하면 좋을지 생각해보고 각 단계별로 유효성 검증을 하면된다
이번 시간에는 폼에서 폼 필드와 clean_필드 메소드를 이용해 유효성 검증하는 방법을 알아보았다

--------------------------------------------------------------------------------------------------------------------------------------------------

내 마음대로 form 다루기

자 이때까지 작성했던 폼들을 보면 기능들은 잘 작동하는데 너무 못생겼다 이번에는 이러한 폼을 내 입맛에 맞게 사용하는 법을 배워보자 post_form.html 로 가서 템플릿을 수정하면 되는데 

<form method="post">{% csrf_token %}
    {{form.as_ul}}
    <input type="submit" value="전송">
</form>

지금은 장고에서 제공하는 형태로 알아서 작성되도록 되어있다 자 그런데 우리는 여기 이 폼에서 제목은 위로 올리고 그 다음 글자를 좀 더 크게 한 다음에 입력하는 위젯은 그 밑으로 내려보자 
내용도 마찬가지로 좀 이쁘게 꾸미도록 해보자 자 이럴때는 지금처럼 장고에서 위에서처럼 한번에 되도록 적어주는 것이 아니라 개별 컴포넌트로서 접근이 필요하다 한번 해보자 

<form method="post">{% csrf_token %}
    <h3>제목</h3>
    <p>{{form.title}}</p>
    <h3>내용</h3>
    <p>{{form.content}}</p>
    <input type="submit" value="전송">
</form>

이렇게 고치고 개발서버를 키면 이쁘게 변했다 그런데 위의 코드대로 제목과 내용을 입력하고 전송 버튼을 누르게 되면 유효성 검증에 대한 내용이 아무것도 출력되지 않는다 이건 바로 우리가 에러 메세지에 대한
처리를 안해줬기 때문이다 장고가 사용하는 폼 렌더 형식 앞에서 설명했던 .as_ul, .as_p 등을 사용하면 장고가 제공하는 형식을 사용하는 것이므로 에러 메세지에 대한 표시도 함께 나오게 되지만 지금처럼 따로 커스텀해서
사용하게 되면 에러 메세지를 표시하도록 만들어줘야한다 그럼 한번 해보자 post_form.html로 가서 에러 메세지를 추가하도록 해보자 에러메세지는 한개가 아니라 여러개일 수 있기 때문에 for 루프를 이용해서 다뤄준다

<form method="post">{% csrf_token %}
    <h3>제목</h3>
    <p>{{form.title}}</p>
    {% for error in form.title.errors %}
        <p>{{error}}</p>
    {% endfor %}
    <h3>내용</h3>
    <p>{{form.content}}</p>
    {% for error in form.content.errors %}
        <p>{{error}}</p>
    {% endfor %}
    <input type="submit" value="전송">
</form>

짜잔 에러메세지는 폼.필드.errors 를 통해서 접근할 수 있다 개발 서버 열고 해보면 에러 메세지 잘나온다
---------------------------------------------------------------------------------------------------------------------------

Form에 CSS 적용하기 1

자 우선 에러 메시지들을 빨간색으로 바꿔보자 간단한 CSS를 적용해주면된다 VSCode로 가서 static/posts/css 에다가 form.css를 생성한다 

.error {
    color: red;
}

그 다음에 post_form 템플릿으로 가서 작성한 css를 적용시켜주자 CSS를 적용시켜 주기 위해서 일단 기본적인 html 구조를 잡자 기본적인 구조는 base 템플릿에서 상속하자
base.html 의 css 블록을 form.html에 구현하자 그리고 base.html 의 content 블락을 form.html에 구현하고 그 안에 기존에 있던 form.html의 form 태그 부분을 넣어주자
->
{% extends "./base.html" %}
{% load static %}

{% block css %}
    <link rel="stylesheet" href="{% static 'posts/css/form.css' %}">
{% endblock css %}

{% block content %}
    <form method="post">{% csrf_token %}
        <h3>제목</h3>
        <p>{{form.title}}</p>
        {% for error in form.title.errors %}
            <p class="error">{{error}}</p>
        {% endfor %}
        <h3>내용</h3>
        <p>{{form.content}}</p>
        {% for error in form.content.errors %}
            <p class="error">{{error}}</p>
        {% endfor %}
        <input type="submit" value="전송">
    </form>
{% endblock content %}

이제 위의 에러 문구 p 태그에다가 클래스도 적용했다 개발서버 켜고 들어가면 잘나온다

-----------------------------------------------------------------------------------------------------------------

Form에 css 적용하기 2

이번에는 form의 세부 요소들에 css를 적용하고 글 작성 페이지에 디자인을 입혀보자 먼저 제목을 입력하는 위젯에 css를 적용해서 width 즉 너비를 변경해보자
에러 메세지 같은 경우에는 p 태그에 클래스를 적용했지만 제목같은 경우에는 에러메세지 처럼 바로 아이디나 클래스를 적용할 수 없다 그 이유는 입력하는 input 태그 안에 있는 위젯에 대한
스타일을 변경해야 되는데 지금은 장고 form에서 위젯에 대한 스타일을 자동으로 지정해주고 있기 때문이다

<form method=="post">
    <label for="title">제목</label>
    <input type="text" id="title" name="title">
</form>

만약 위의 폼과 위젯을 html로 구현했다면

<form method=="post">
    <label for="title">제목</label>
    <input type="text" id="title" name="title" style="width:100">
</form>

위 처럼 적어서 적용하거나 

html
<form method=="post">
    <label for="title">제목</label>
    <input type="text" id="title" name="title">
</form>

css
#title{
  width : 100;
 }
 
위처럼 css에 아이디를 사용해서 적용하면 되는데 우리는 이러한 설정들을 템플릿에서 바로 접근할 수 없고 폼을 정의한 forms.py에서 접근할 수 있다 자 그럼 forms.py로 가보자

from django import forms
from .models import Post
from .validators import validate_symbol
from django.core.exceptions import ValidationError

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields =['title', 'content']
    
    def clean_title(self):
        title = self.cleaned_data["title"]
        if "*" in title:
            raise ValidationError("*는 포함될 수 없습니다")
        return title
        
여기 보면 title과 content 필드를 장고가 자동으로 모델을 보고 유추해서 사용하고 있다 models.py를 보면 title 같은 경우에는 CharField를 사용하고 있다 자 그럼 이제 장고 공식문서를 켜서
이러한 CharField 같은 모델 필드를 변환할 때 장고는 어떤 위젯을 사용하는지 한번 봐보자 검색창에다가 django form charfield 라고 처보자 
-> https://docs.djangoproject.com/en/4.0/ref/forms/fields/ 
공식 문서로 가서 CharField라고 검색해보면 다음과 같이 발견할 수 있다 

CharField¶

class CharField(**kwargs)¶

        Default widget: TextInput
        Empty value: Whatever you’ve given as empty_value.
        Normalizes to: A string.
        Uses MaxLengthValidator and MinLengthValidator if max_length and min_length are provided. Otherwise, all inputs are valid.
        Error message keys: required, max_length, min_length

    Has four optional arguments for validation:

    max_length¶

    min_length¶

        If provided, these arguments ensure that the string is at most or at least the given length.

    strip¶

        If True (default), the value will be stripped of leading and trailing whitespace.

    empty_value¶

        The value to use to represent “empty”. Defaults to an empty string.

여기 보면 CharField 같은 경우 기본 위젝은 TextInput 이다 우리가 앞에서 보았던 길쭉한 한줄 입력창이다 다시 돌아가서 forms.py로 가서 정리를 해보면 자 우리는 ModelForm을 사용하고 
이 title 같은 경우에는 모델의 CharField로 정의가 되어있으며 이러한 CharField는 폼으로 변환될 때 TextInput을 기본 위젯으로 사용한다는 것을 알고 있다 그럼 forms.py로 가서 다음과 같이 적어주자

from django import forms
from .models import Post
from .validators import validate_symbol
from django.core.exceptions import ValidationError

class PostForm(forms.ModelForm):
    # memo = forms.CharField(max_length=50, validators=[validate_symbol])
    class Meta:
        model = Post
        fields =['title', 'content']
        widgets = {'title' : forms.TextInput}
    def clean_title(self):
        title = self.cleaned_data["title"]
        if "*" in title:
            raise ValidationError("*는 포함될 수 없습니다")
        return title

widgets 변수를 만들어줬다 이 widgets 은 사전형 변수로 필드 이름을 키로 하고 적용할 위젯을 값으로 해서 폼 필드마다 위젯을 직접 명시할 수 있게 해준다 기본 위젯 말고 다른 위젯을 사용하거나 지금처럼 
위젯에 접근해야 될 때 쓰인데 원래 TextInput은 title 필드의 기본 위젯이었다 우린 여기서 다양한 스타일을 적용할 수 있다 아이디나 클래스등을 사용하면 된다 먼저 스타일을 적용하자 form.css 로 가자
다음과 같이 추가해주자

.title {
    width: 400px;
}

그리고 다시 forms.py 로 가자 widgets = {'title' : forms.TextInput}  이 라인을 다음과 같이 고친다
-> widgets = {'title' : forms.TextInput(attrs={'class':'title'})}
이러면 여기 TextInput 이라는 위젯은 속성으로 클래스가 title이라는 것을 갖게되는것이다 그리고 스타일 하나를 더 줘보자 그 다음에 다른 스타일을 더 주자
유저가 처음으로 타이틀을 입력할 때 위젯 안에 제목을 입력하세요 같은 텍스트가 나오도록 해보자 이런건 css 속성중에 placeholder 라는것을 쓰면 된다
->
        widgets = {'title' : forms.TextInput(attrs=
            {'class':'title',
            'placeholder' : "제목을 입력하세요"})}

자 그럼 이제 content 에다가도 placeholder 를 지정해주자
->
from django import forms
from .models import Post
from .validators import validate_symbol
from django.core.exceptions import ValidationError

class PostForm(forms.ModelForm):
    # memo = forms.CharField(max_length=50, validators=[validate_symbol])
    class Meta:
        model = Post
        fields =['title', 'content']
        widgets = {'title' : forms.TextInput(attrs=
                      {'class':'title',
                      'placeholder' : "제목을 입력하세요"}),
                   'content' : forms.Textarea(attrs=
                      {'placeholder' : "내용을 입력하세요"})}
    def clean_title(self):
        title = self.cleaned_data["title"]
        if "*" in title:
            raise ValidationError("*는 포함될 수 없습니다")
        return title

자 이제 개발 서버 켜고 확인하자 잘나온다~~~~~~~~~~~~~₩
-----------------------------------------------------------------------------------------------------------------------------

그러면 이제 미리 작성해놓은 css 파일을 이용해서 조금 더 이쁘게 글쓰기 페이지를 바꿔보자 post_form.html 위쪽에 css 파일을 바꿔주도록 하자 post_form.css로 바꿔주자 그리고 수업파일을 다운 받아 css폴더 안에 넣었다
자 이제 이 css 파일에 맞춰 html 파일을 고쳐주도록 하자

바꾸기 전 post_form.html

{% extends "./base.html" %}
{% load static %}

{% block css %}
    <link rel="stylesheet" href="{% static 'posts/css/post_form.css' %}">
{% endblock css %}

{% block content %}
    <form method="post">{% csrf_token %}
        <h3>제목</h3>
        <p>{{form.title}}</p>
        {% for error in form.title.errors %}
            <p class="error">{{error}}</p>
        {% endfor %}
        <h3>내용</h3>
        <p>{{form.content}}</p>
        {% for error in form.content.errors %}
            <p class="error">{{error}}</p>
        {% endfor %}
        <input type="submit" value="전송">
    </form>
{% endblock content %}

이 코드에 추가하자 일단 post_header 라는 block을 만든다
->
{% block post_header%}
    <div class="container">
        <h1>글쓰기</h1>
    </div>
{% endblock post_header%}

그리고 작성됬던 폼 컴포넌트를 div 태그로 묶어주고 editor 클래스로 만든다 그리고 h3 태그로 묶여있는 제목이랑 내용을 지워준다 그리고 전송 버튼을 위로 옮겨준 후 작성완료라고 바꿔준다
그리고 이 input 태그를 div 태그로 감싸고 클래스로 submit을 준다 자 이제 개발 서버 켜고 확인해보자 잘나온다

지금 보면 돌아가기 버튼이 없는데 돌아가기 버튼도 하나 만들어주자 content block 맨 밑에 적자
->
{% extends "./base.html" %}
{% load static %}

{% block css %}
    <link rel="stylesheet" href="{% static 'posts/css/post_form.css' %}">
{% endblock css %}

{% block post_header%}
    <div class="container">
        <h1>글쓰기</h1>
    </div>
{% endblock post_header%}

{% block content %}
    <form method="post">{% csrf_token %}
        <div class="submit">
            <input type="submit" value="작성완료">
        </div>
        <div class="editor">
            <p>{{form.title}}</p>
            {% for error in form.title.errors %}
                <p class="error">{{error}}</p>
            {% endfor %}
            <p>{{form.content}}</p>
            {% for error in form.content.errors %}
                <p class="error">{{error}}</p>
            {% endfor %}
        </div>
    </form>
    <div class="btn_back">
        <a href="{% url 'post-list' %}">돌아가기</a>
    </div>
{% endblock content %}

개발 서버 켜고 확인해보자 잘나온다~~
------------------------------------------------------------------------------------------------------------

실습과제
100XP
일기장이 예뻐야 일기도 써지는 법

지금의 일기 작성 페이지는 일기를 작성할 의욕마저 잃게 해요. 아래를 참고해서 일기 작성 페이지에 이쁜 디자인을 입혀 주세요.

    page_form 템플릿으로 가서 [A]~[G]를 작성해 주세요.

    개발 서버를 켜고 일기 쓰기 페이지로 가서 아래와 같이 디자인이 적용 되었는지 확인해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4147&directory=Untitled.png&name=Untitled.png

    데이터를 한 번 입력해 보면 Django가 지원하는 기본 폼 형식으로 렌더링 한 것이 아닌 각각의 폼 요소들을 직접 구현해 주었기 때문에 유효성 에러 메세지가 나오지 않습니다. 우리는 아직 유효성 검사 메세지를 보이도록 작성하지 않았거든요. 아래의 [A] ~ [D]를 참고해서 page_form 템플릿을 수정해 주세요.

    유효성 검증 에러 메세지는 한 번에 여러개가 출력될 수 있기 때문에 
    템플릿 태그 for와 함께 사용합니다.

    감정 점수, 제목, 상태 아래에 각각의 에러 메세지들을 작성합니다.

    <div class="input input-score">
        <p>감정 점수</p>
        <!--감정 점수 필드-->
        {% for error in <!--[A] 감정 점수 필드 에러--> %}
        <span>{{error}}</span>
        {% endfor %}
    </div>

    <div class="input input-title">
        <p>제목</p>
        <!--제목 필드-->
        {% for error in <!--[B] 제목 필드 에러--> %}
        <span>{{error}}</span>
        {% endfor %}
    </div>

    <div class="input input-state">
        <p>상태</p>
        <!--상태 필드-->
        {% for error in <!--[C] 상태 필드 에러--> %}
          <span>{{error}}</span>
        {% endfor %}
    </div>

    <!--내용 필드-->
    {% for error in <!--[D] 감정 점수 필드 에러--> %}
        <span>{{error}}</span>
    {% endfor %}

    다시 개발 서버를 켜고 유효하지 않은 데이터를 입력해 보고 우리가 작성했던 에러 메세지가 나오는지 확인해 주세요.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4147&directory=Untitled%201.png&name=Untitled+1.png

과제 해설close solution tab

    이번에는 일기 작성 페이지에 스타일을 입혀 보겠습니다.
        먼저 page_form 템플릿으로 가서 템플릿 상속 및 block 처리를 해주겠습니다.

    {% extends './base.html' %} <!-- [A] base 템플릿을 상속 합니다.-->

    {% block content %} <!-- [B] content 블럭 처리 -->
    <div class="wrap-post">
        <form method="post">{% csrf_token %}
            ...
        </form>
    </div>
    {% endblock content %} <!-- [B] content 블럭 처리 -->

        다음으로 각각의 입력 필드를 작성하면 되는데 이러한 입력 필드는 page_create 뷰에서 넘겨준 form으로 접근할 수 있습니다.
        지금 작성하는 class나 div등의 구조는 미리 작성해놓은 styles.css를 따른 것입니다. 이러한 부분들은 다양한 디자인 템플릿에 맞게 매번 변경되기 때문에 우리가 템플릿 언어로 작성해서 여러 데이터나 컴포넌트를 템플릿에 적용하는 과정을 이해하는 것이 중요합니다.

    {% extends './base.html' %}

    {% block content %} 
    <div class="wrap-post">
        <form method="post">{% csrf_token %}
            <div class="editor">

                <div class="input input-date">
                    <p>날짜</p>
                    {{form.dt_created}} <!-- [C] 날짜 입력 필드-->
                </div>

                <div class="input input-score">
                    <p>감정 점수</p>
                    {{form.score}} <!-- [D] 감정 점수 입력 필드-->
                </div>

                <div class="input input-title">
                    <p>제목</p>
                    {{form.title}} <!-- [E] 제목 입력 필드-->
                </div>

                <div class="input input-state">
                    <p>상태</p>
                    {{form.feeling}} <!-- [F] 감정 상태 입력 필드-->
                </div>

                {{form.content}} <!-- [G] 일기 내용 입력 필드-->

                <div class="post-btn">
                    <input type="submit" value="작성완료">
                </div>
                
            </div>
        </form>
    </div>
    {% endblock content %} 

    개발 서버를 켜고 일기 작성 페이지로 들어가보면 디자인이 적용되어 있는 것을 확인할 수 있습니다.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4147&directory=Untitled.png&name=Untitled.png

    이전에는 {{ form.as_p }} 를 통해 Django가 제공하는 템플릿 형식을 따랐기 때문에 에러 메세지가 표시 되었지만 이제는 우리가 각각의 폼 요소들을 따로 가져다 쓰고 있으므로 에러 메세지가 표시 될 수 있도록 작성해 주어야 합니다.
        에러 메세지는 아래와 같이 각각의 필드 안의 errors를 이용해서 반복 표시되도록 구현합니다.
        하나의 필드에 대해 여러가지 에러가 나올 수 있기 때문입니다.

    {% for error in example_field.errors %}
        <span>{{error}}</span>
    {% endfor %}

        각각의 필드에 대해 작성해 줍니다.

    {% extends './base.html' %}

    {% block content %}
    <div class="wrap-post">
        <form method="post">{% csrf_token %}
            <div class="editor">
                <div class="input input-date"><p>날짜</p>{{form.dt_created}}</div>

                <div class="input input-score">
                    <p>감정 점수</p>
                    {{form.score}}
                    {% for error in form.score.errors %} <!-- 에러메시지 작성 -->
                        <span>{{error}}</span>
                    {% endfor %}
                </div>
                 
                <div class="input input-title">
                    <p>제목</p>
                    {{form.title}}
                    {% for error in form.title.errors %} <!-- 에러메시지 작성 -->
                        <span>{{error}}</span>
                    {% endfor %}
                </div>
                
                <div class="input input-state">
                    <p>상태</p>
                    {{form.feeling}}
                    {% for error in form.feeling.errors %} <!-- 에러메시지 작성 -->
                        <span>{{error}}</span> 
                    {% endfor %}
                </div>
                
                {{form.content}}
                {% for error in form.content.errors %} <!-- 에러메시지 작성 -->
                    <span>{{error}}</span>
                {% endfor %}

                <div class="post-btn">
                    <input type="submit" value="작성완료">
                </div>
            </div>
        </form>
    </div>
    {% endblock content %}

    개발 서버를 켜고 유효성 검증에 실패 했을 때 아래와 같이 에러 메시지가 잘 나오는지 확인합니다.

    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4147&directory=Untitled%201.png&name=Untitled+1.png

----------------------------------------------------------------------------------------------------------------------------------

blank는 데이터베이스에 빈 값을 저장할지 여부를 결정한다. -> False
blank는 유저의 입력과 관련된 부분으로 기본값은 False이며 True로 설정할 경우 유저가 해당 필드를 입력하지 않아도 검증을 통과하게 됩니다.

필드 옵션 중 'blank'는 데이터베이스에 빈 값을 허용할지 여부를 결정하는 옵션이다. -> False
blank 옵션은 폼에 입력할 때 빈 값을 허용할지 여부로 데이터베이스에 저장하는 것과는 별개인 옵션입니다.

----------------------------------------------------------------------------------------------------------------------------------
글 수정하기

게시글 상세페이지 오른쪽 하단에 수정 버튼을 만들거다 수정 버튼을 누르면 글쓰기 버튼을 눌렀을 때랑 같은 폼에 기존의 내용이 입력되 있는 형태가 나와야한다 그리고 작성 완료를 누르면 수정이 되도록 만들거다
바로 구현하자 모든 기능의 시작은 url이다! urls.py로 가서 post-update 라고 name을 주고 를 코멘트 해제한다 그리고 post_detail.html로 가자 그리고 목록으로 버튼 줄 아래에다가 다음과 같이 쓰자
->         <div class="btn_modify"><a href="{% url 'post-update' post.id %}">수정하기</a></div>
그리고 이 줄을 다시 div 태그로 감싸고 right-btn 클래스를 부여한다
->
        <div class="right-btn">
            <div class="btn_modify"><a href="{% url 'post-update' post.id %}">수정하기</a></div>
        </div>

자 다음으로는 뷰로 가보자 post_update 뷰를만들어 줘야겠지? post.id 가 post_id 인자로 전달되서 post_update 인자로 들어가게된다 
그냥 폼을 보여주느게 아니라 기존의 데이터가 채워져 있어야하므로 해당 포스트의 데이터를 가져와야한다
-> post = Post.objects.get(id=post_id)

자 이제 폼을 만들어주자
-> post_form = PostForm(instance=post)

기존의 모델을 폼에 넘겨주는 인자로 instance 를 사용하였다 이렇게하면 기존의 데이터가 폼에 바운드된다
그리고 return render(request, "posts/post_form.html", {'form' : post_form}) 렌더해준다
->
def post_update(request, post_id):
    post = Post.objects.get(id=post_id)
    post_form = PostForm(instance=post)

    return render(request, "posts/post_form.html", {'form' : post_form})
    
이 다음에 해줘야하는건 수정된 글을 저장하는것이다 유저가 글 작성 버튼을 누르면 post 방식으로 요청이 들어간다 그러면 전에 작성했던 post_create 이랑 비슷하게 하면 된다
->
    if request.method == "POST":
        post_form = PostForm(request.POST, instance=post)
        
instance=post 이런식으로 인자를 주는 이유는 작성된 데이터와 폼을 바인딩하는데 이 때 새로운 모델 객체를 갖는 폼을 생성하는것이 아니라 기존에 작성되었던 POST 모델 인스턴스와 수정된 데이터를 갖는 폼을 만드는것이다
이 부분이 핵심이다 그리고 유효성 검증도 해주고 리디렉도 해주자
->
        if post_form.is_valid():
            post_form.save()
            return redirect('post-detail', post_id=post.id)

이제 POST 가 아닌 GET 방식으로 요청이 올 때를 구현하자 즉 상세페이지에서 글 수정하기를 눌러서 처음 들어온 상태라면 이미 작어놓았던 post_form = PostForm(instance=post) 이 부분이다 이걸 else 아래 넣기만 하자
->
def post_update(request, post_id):
    post = Post.objects.get(id=post_id)
    if request.method == "POST":
        post_form = PostForm(request.POST, instance=post)
        if post_form.is_valid():
            post_form.save()
            return redirect('post-detail', post_id=post.id)
    else:
        post_form = PostForm(instance=post)

    return render(request, "posts/post_form.html", {'form' : post_form})

자 완성! 개발서버 켜고 해봐라
-------------------------------------------------------------------------------------------------------------------------------
실습과제
100XP
감정도 수정할 수 있을까요

지금은 상세 일기 보기 페이지에서 '수정하기'를 눌러도 아무런 반응이 없습니다. 아래를 참고해서 상세 일기 보기 페이지의 '수정하기'를 구현해 주세요.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4150&directory=Untitled.png&name=Untitled.png

    urls.py로 가서 수정하기에 해당하는 url 패턴을 주석 해제해 주세요.

    page_detail 템플릿으로 가서 수정하기 페이지로 가는 링크를 url 템플릿 태그를 이용해서 작성해 주세요.

    views.py로 가서 page_update 뷰를 작성해 주세요.
     page_update 뷰는 먼저 수정할 데이터를 데이터 베이스에서 조회합니다.

    def page_update(...):
        object = <수정 할 Page 데이터를 조회>

    POST

    요청이 POST 방식인 경우는 사용자가 데이터를 수정하고 전송을 눌렀을 때입니다.

    def page_update(...):
        object = <수정 할 Page 데이터를 조회>
        if <request가 POST 방식이라면>:
            form = PageForm(<request에 저장되어 있는 데이터>, instance=<조회한 데이터>)
            if <유효한 데이터라면>:
                <데이터를 저장하고>
                return <일기 상세 보기 페이지로 redirect>

    요청이 POST 방식이라면 현재 request에 저장되어 있는 데이터와 데이터 베이스에서 조회한 Page 데이터 모델을 이용해서 PageForm을 만들어 주세요. PageForm의 instance 파라미터를 이용합니다.
     그리고 작성한 form을 이용해서 유효성 검증을 한 후 유효한 데이터라면 데이터 베이스에 저장한 다음
     데이터를 저장한 뒤 수정 된 데이터를 볼 수 있는 일기 상세 보기 페이지로 redirect 하도록 작성해 주세요.
    GET

    요청이 GET 방식인 경우는 처음 수정 페이지에 들어왔을 때이므로 기존의 데이터를 보여주고 수정할 수 있는 페이지를 제공해야 합니다.

    def page_update(...):
        object = <수정 할 Page 데이터를 조회>
        if <request가 POST 방식이라면>:
            # POST 로직
        else:
            form = PageForm(instance=<조회한 데이터>)

    입력 할 수 있도록 PageForm을 생성하는데 이때 비어 있는 폼이 아닌 조회한 데이터로 채워진 폼을 제공합니다. instance 파라미터를 사용하세요.
    return

    def page_update(...):
        object = <수정 할 Page 데이터를 조회>
        if <request가 POST 방식이라면>:
            # POST 로직
        else:
            # GET 로직
        return render(...)

    page_form 템플릿을 랜더해서 결과로 돌려주도록 작성해 주세요. 이때 위에서 생성한 form을 함께 템플릿으로 전달해야 합니다.

    개발 서버를 켜고 상세 일기 보기 페이지로 가서 정상적으로 수정이 되는지 확인해 주세요.

과제 해설close solution tab

    이번에는 수정하기 기능을 구현해 보도록 하겠습니다. 먼저 urls.py로 가서 page-update를 주석 해제 해주세요.

    from django.urls import path
    from . import views

    urlpatterns = [
        path('diary/', views.page_list, name='page-list'),
        path('diary/info', views.info, name='info'),
        path('diary/write/', views.page_create, name='page-create'),
        path('diary/page/<int:page_id>/', views.page_detail, name='page-detail'),
        path('diary/page/<int:page_id>/edit/', views.page_update, name='page-update'),
        # path('diary/page/<int:page_id>/delete/', views.page_delete, name='page-delete'),
    ]

    page_detail 템플릿으로 가서 수정하기로 가는 링크를 작성해 주겠습니다. url 템플릿 태그를 이용해서 작성하면 되겠죠? 이때 수정할 데이터를 조회해야 하므로 조회를 위한 object.id도 함께 적어줍니다.

    {% extends './base.html' %}

    {% block content %}
    <div class="wrap-notetext">
        <div class="notetext">
            <div class="text-box">
               ...
                <div class="notetext-btn">
                    <ul>
                        <li><a href="#">삭제하기</a></li>
                        <li><a href="{% url 'page-update' object.id %}">수정하기</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    {% endblock content %}

    views.py로 가서 page_update 뷰를 작성해 보겠습니다.
        page_update 뷰는 request와 page_id 파라미터가 필요합니다.
        이 page_id를 사용해서 수정할 Page 데이터 모델을 조회합니다.

    def page_update(request, page_id):
        object = Page.objects.get(id=page_id)

    POST
        요청이 POST 방식 이라는 것은 사용자가 데이터를 수정하고 제출을 했다는 것을 의미합니다. 우리는 입력된 데이터를 받아서 유효성을 검사하고 데이터베이스에 저장한 후 일기 상세 보기 페이지로 안내 하면 됩니다.
        Create와 달리 Update는 새로 Page 데이터 모델을 만들어서 저장하는 것이 아니라 기존의 데이터 모델을 수정해야 하므로 PageForm의 instance 파라미터로 조회한 데이터 모델을 넘겨주어야 합니다.

    def page_update(request, page_id):
        object = Page.objects.get(id=page_id)
        if request.method == 'POST': # 요청이 POST 방식이라면
            form = PageForm(request.POST, instance=object) # 기존의 데이터 모델에 새로운 데이터를 설정하고
            if form.is_valid(): # 유효성 검사를 통과했다면
                form.save() # 데이터를 저장한 뒤
                return redirect('page-detail', page_id=object.id) # 상세 보기 페이지로 안내합니다.
       

    GET
        요청이 GET 방식 이라는 것은 사용자가 처음 수정하기 페이지에 왔을때를 의미합니다.
        이때 우리는 비어있는 폼 형식의 페이지가 아니라 기존 데이터가 채워진 상태의 폼을 제공해야 하므로 PageForm의 instance 파라미터에 조회한 Page 데이터 모델을 넘겨줍니다.

    def page_update(request, page_id):
        object = Page.objects.get(id=page_id)
        if request.method == 'POST':
            form = PageForm(request.POST, instance=object)
            if form.is_valid():
                form.save()
                return redirect('page-detail', page_id=object.id)
        else:
            form = PageForm(instance=object)

    return
        마지막으로 POST와 GET에서 작성한 form을 이용해서 page_form 템플릿을 랜더한 후 결과로 돌려주도록 작성합니다.
        이렇게 하게 되면 요청 방식이 POST 일 때는 'form'이 입력된 데이터가 들어간 form이 되고 만약 데이터가 유효하다면 데이터를 저장하고 상세 페이지로 가며, 유효하지 않다면 form에 입력된 데이터를 갖고 있는 그대로 return을 향하게 됩니다.
        요청 방식이 GET 방식 일 때는 폼에 기존 데이터를 넣은 후 다른 로직이 없으므로 return을 향하게 되는거죠.
        그러면 return에서는 각각 작성된 form을 page_form 템플릿으로 넘겨서 렌더한 후 결과로 돌려주면 됩니다.

    def page_update(request, page_id):
        object = Page.objects.get(id=page_id)
        if request.method == 'POST':
            form = PageForm(request.POST, instance=object)
            if form.is_valid():
                form.save()
                return redirect('page-detail', page_id=object.id)
        else:
            form = PageForm(instance=object)
        return render(request, 'diary/page_form.html', {'form': form})

    개발 서버를 켜고 상세 일기 보기 페이지로 가서 정상적으로 수정이 되는지 확인해 주세요.

-----------------------------------------------------------------------------------------------------------------------------------------------

포스트 삭제하기

미리 작성해놨던 url 코멘트 해제하고~ post-delete 네임도 준다 그리고 post_detail.html로 가서 수정버튼 줄 밑에다가 삭제 버튼을 적어보자
            <div class="btn_delete"><a href="{% url 'post-delete' post.id %}">삭제하기</a></div>

그리고 뷰로 가서 post_delete 뷰를 만들자 그리고 삭제할 데이터를 가져오도록 하자 -> post = Post.objects.get(id=post_id)
그 다음에 포스트를 삭제한다 -> post.delete()
그리고 포스트 리스트 페이지로 가게 리디렉트 해준다 -> return redirect('post-list')

def post_delete(request, post_id):
    post = Post.objects.get(id=post_id)
    post.delete()
    
    return redirect('post-list')
    
자 이러면 삭제 기능은 구현이 끝난다 개발 서버 들어가서 아무 글이나 삭제 누르면 잘 삭제된다! 근데 삭제 버튼을 누르면 바로 삭제되버리지? 한번의 클릭으로 글이 날아거 버리는것은 위험하다
정말 글을 삭제하려는것이 맞는지 한번 더 물어보고 네라고 할 시 삭제하도록 만들어보겠다 post_confirm_delete.html 이라는 템플릿을만들어준다 이미 수업에서 만들어주었다 
->
{% extends './base.html' %}
{% load static %}

{% block css %}
    <link rel="stylesheet" href="{% static 'posts/css/post_confirm_delete.css' %}">
{% endblock css %}

{% block content %}
<div class="confirm">
    <p class="title">[{{post.title}}]</p>
    <p>삭제하시겠습니까?</p>
    <form method="POST">{% csrf_token %}
        <div class="confirm_btn">
            <input type="submit" value="삭제하기">
        </div>
    </form>
</div>
{% endblock content %}

여기선 장고폼을 쓸 필요가 없어 그냥 html 폼을 썼다 템플릿은 이걸로 됬고 뷰로 가자 post_delete 을 바꿔줘야한다
->
def post_delete(request, post_id):
    post = Post.objects.get(id=post_id)
    if request.method == "POST":
        post.delete()
        return redirect('post-list')
    else:
        return render(request, "posts/post_confirm_delete.html", {'post' : post})
        
POST 일 때 그러니까 post_confirm_delete 템플릿에서 버튼을 눌렀을 때는 포스트를 지워주고 아닐 때는 post_confirm_delete 템플릿을 렌더해준다
자 이제 개발서버 켜고 확인해봐라
---------------------------------------------------------------------------------------------------------------------------------

