CRUD 
데이터를 다룰 때 만드시 필요한 네가지 기능 앞에서는 CRUD를 모델과 관련된 기능 정도로만 소개했지만 CRUD는 데이터베이스를 넘어 웹사이트에서 가장 핵심적인 기능이다
유투브 페이스북등 거의 모든 웹사이트는 이 CRUD 기능이 핵심이다 우리는 글 작성 부터 조회 수정 삭제까지 가능한 블로그를 한번 만들어보자

django-admin startproject costory   -> 새 프로젝트를 만들자
cd costory
code .

초기 설정을 해보자 

settings.py 가서 Time Zone을 보자 TIME_ZONE 은 장고 프로젝트가 동작할 때 기준으로 삼을 시간대를 설정해준다 장고가 기본적으로 설정하는 시간대는 UTC이다
시간 설정을 한국으로 하려면 'Asia/Seoul' 이라고 하면 된다

Time Zone : https://docs.djangoproject.com/en/3.2/topics/i18n/timezones/

그리고 블로그 웹사이트에서 포스트 기능을 다룰 posts라는 앱을 생성한다 VSCode 창 띄워놓고 맨 위에 보면 Terminal 탭이 있다 그 아래 보면 New Terminal이 있는데 이거 누르면
VSCode 창에서 터미널 띄울수 있다!

python3 manage.py startapp posts 

그리고 settings.py의 INSTALLED_APPS애 등록해주자

자 그리고 장고 기본 데이터구조를 데이터베이스에 반영하자 INSTALLED_APPS 에 보면 우리가 생성한 앱 말고도 다양한 기본 앱이 있다 migrate를 하면 이 앱들이 필요한 데이터구조가 생성된다
-> python3 manage.py migrate
->
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, foods, menus, sessions
Running migrations:
  No migrations to apply.

자 이제 개발 서버 켜고 잘 되는지 들어가보자
----------------------------------------------------------------------------------------------------------------------------
URL 구조 만들기

Costory 웹사이트의 URL 구조를 생각해보고 전체 웹 사이트의 틀을 잡아보자 웹 사이트의 기능은 URL을 잘 정의 하는 것에서 시작한다

'' (root) -> 블로그의 홈페이지
/posts ->  전체 포스트 조회 (read)
/posts/<post_id> -> 개별 포스트 조회 (read)
/posts/new -> 새 포스트 작성 (create)
/posts/<post_id>/edit -> 포스트 수정 (update)
/posts/<post_id>/delete -> 포스트 삭제 (delete)

그러면 실재로 URL을 작성해보자

앞으로 사용할 URL 구조 -> 이건 강의 밑에 노트로 적혀있던건데 강의에서 URL구조랑 조금 다른데? 흠 
url	설명
/posts/	블로그의 홈페이지
/posts/<post_id>/	개별 포스트 조회
/posts/new/	포스트 작성
/posts/<post_id>/edit/	포스트 수정
/posts/<post_id>/delete/	포스트 삭제

아무것도 없는 domain/ 으로 들어오면 바로 posts 앱의 url로 연결시키자 프로젝트 앱의 urls.py 를 열고 추가한다 일단 include를 inport 해 주고 
path('', include('posts.urls')), 이렇게 경로를 추가해주면 이제 장고가 localhost:8000 과 localhost:8000 뒤에 붙는 추가적인 url 모두 posts 앱의 urls.py를 보고 처리하게 된다
근데 지금 posts 앱에 urls.py 가 없으니 urls.py 를 만들어주자 그리고 안에다 적어주자

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index),
    path('posts/', views.post_list),
    path('posts/new', views.post_create),
    path('posts/<int:post_id>/', views.post_detail),
    path('posts/<int:post_id>/edit', views.post_update),
    path('posts/<int:post_id>/delete', views.post_delete),
]

그리고 path 들은 지금은 주석처리 해주자 아직 view를 구현 안해서 이렇게 실핼하면 에러가 난다
---------------------------------------------------------------------------------------------------------------
path 인자에서 슬래시 유무
posts/, posts/<int:post_id>/ 등에는 끝에 슬래시를 붙이는데,

posts/new, posts/<int:post_id>/ edit 등은 끝에 슬래시를 안 붙여서 차이점이 뭔지 궁금합니다.

먼저 slash 가 필요한 이유는 https://docs.djangoproject.com/en/2.2/ref/settings/#append-slash 에서 속성값이 True 가 기본이기 때문이에용

그래서 / 가 붙지 않으면 올바르게 url 과 view 등이 매칭되지 않을 수 있습니당.

  

이 이유를 근본적으로 좀 생각해보면 좋을텐데용,

장고 디자인 철학에 의하면 다음과 같이 쓰여 있습니다(https://docs.djangoproject.com/en/2.2/misc/design-philosophies/#definitive-urls)

  

    Technically, foo.com/bar and foo.com/bar/ are two different URLs, and search-engine robots (and some Web traffic-analyzing tools) would treat them as separate pages. Django should make an effort to “normalize” URLs so that search-engine robots don’t get confused.

  

이 trailing slash 에 대해 좀 더 살펴보자면 https://djkeh.github.io/articles/Why-do-we-put-slash-at-the-end-of-URL-kor/ 를 참고해보시면 좋습니당.

결국 이런 차이가 있기 때문에 Djagno 에서는 trailing slash 를 쓰는 걸 기본으로 채택하고 있는거라 생각해용

그런 의미에서 위와 같이 7, 9, 10 번 라인에서도 / 을 끝에 붙이는게 맞다고 생각합니당. 오기가 아닐까 싶어용
--------------------------------------------------------------------------------------------------------------------------------------

Model 만들기

블로그에서 사용할 데이터 구조 즉 모델을 정의하자 posts 앱 -> models.py 
장고에서 모델을 정의할때는 models.Model을 상속받아 정의한다 -> class Post(models.Model) 그리고 아래에 모델 필드를 작성해야한다 필요한 필드는 글의 제목, 내용, 작성일, 마지막 수정일
글의 제목 -> title = models.CharField(max_length=50)
글의 내용 -> content = models.TextField()  -> TextField와 CharField의 다른점은 TextField는 최대 길이의 대한 정의가 필요 없다 내용같은 긴 문자열은 항상 TextField를 쓰고 제목 같은 짧은 문자열은 CharField를 쓰자
작성일 -> dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True) -> DateTimeField는 날짜와 시간을 함께 담을 수 있다 인자로 verbose_add이 있는데 이는 사람이 읽기
좋은 필드명을 지정해준다 즉 지금은 DateTime을 편하게 부르기 위해 dt로 줄였지만 나중에 이 필드를 볼 때 알아보기 편하도록 별명을 지어주는것이다 auto_now_add 는 True로 해준다
수정일 -> dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

* DateTimeField : 날짜 + 시간 형식의 필드로 auto_now와 auto_now_add를 매개변수로 가지고 있다
auto_now가 True가 되면 이 포스트가 마지막으로 저장되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 일반적으로 지금처럼 마지막 수정일을 필드로 가지고자 할 때  사용한다
auto_now_add가 True가 되면 이 포스트가 처음 생성되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 지금처럼 데이터 생성일을 필드로 가지고자 할 때 사용한다

auto_now와 auto_now_add 가 둘 다 True이면 에러가 나는데 생각해보면 생성될 때 한번 날짜와 시간을 정하는것과 수정될 때 마다 매번 날짜와 시간을 다시 저장하는 두개가 공존할 수 는 없지?

그리고 마지막으로 def __str__(self): 함수도 써준다 

->

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=50)
    content = models.TextField()
    dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True)
    dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

    def __str__(self):
        return self.title

이제 마이그레이션을 생성하고 반영하면 된다
python3 manage.py makemigrations
python3 manage.py migrate
----------------------------------------------------------------------------------------------------------------------
이런 식으로 클래스로 모델을 만들어 줄 때

(models.Model) 이것을 상속해준다고 하셨는데...

이 의미가 어떤 것인지 잘 모르겠습니다.

좀 더 부연 설명 해주실 수 있을까요...?

상속은 객체지향 코스에서 배우게 되는데, 사실 django 에서 원하는 기능들을 제대로 구현하기 위해선 많은 선수코스들이 존재할겁니당

그래서 장벽을 낮추고자 최소한으로만 선수과제를 표시하셨다고 생각해용

위에서 models 모듈에 Model 이라는 기본 클래스를 상속받게 되는데,

이렇게 상속받아 Post 와 같은 원하는 기능들이 추가된 클래스를 만들게 됩니당

Model 클래스에는 기본적인 기능들이 구현되어 있고,

이를 상속받은 클래스를 통해 필요한 기능들을 나에 맞게 추가한다고 생각하시면 될거에용
---------------------------------------------------------------------------------------------------------------------

모델 필드(Model Field)

Django는 데이터의 타입에 따라 알맞은 필드(Field)를 사용해서 데이터를 다룹니다. 여기서는 우리가 지금까지 사용했던 몇가지 필드 유형과 필드를 정의할 때 사용할 수 있는 옵션들을 정리해 보도록 하겠습니다.
필드 유형(Field Types)

아래는 모델을 정의할 때 데이터에 따라 사용할 수 있는 필드 유형으로 우리가 사용했던 필드들과 그외 타입이 비슷한 필드들의 목록입니다. 이 밖에도 다양한 형식의 필드가 있습니다. 아래의 공식문서를 참고하세요. 
필드 유형 공식문서 바로 가기 https://docs.djangoproject.com/en/2.2/ref/models/fields/#model-field-types
필드명	설명	개별속성
CharField	최대 길이가 정해진 문자열 필드	max_length (최대 글자수)
TextField	최대 길이가 정해지지 않은 문자열 필드	
EmailField	CharField와 같은 문자열 필드지만
입력된 형식이 이메일 형식 인지를 체크하는 필드	max_length=254 (기본값)
URLField	CharField과 같은 문자열 필드지만
입력된 형식이 URL 형식 인지를 체크하는 필드	max_length=200 (기본값)
BooleanField	True, False 값을 갖는 필드	
IntegerField	정수 형식의 필드	
FloatField	부동 소수점 형식의 필드	
DateField	날짜 형식의 필드	auto_now (수정 될 때 마다 새로운 값으로 갱신)
auto_now_add (생성 될 때 값이 입력 되고 추후 변경하지 않음)
TimeField	시간 형식의 필드	auto_now, auto_now_add
DateTimeField	날짜 시간 형식의 필드	auto_now, auto_now_add
필드 옵션(Field options)

모델 필드를 정의할 때 작성할 수 있는 몇 가지 옵션 항목 입니다. 모든 필드에 대해 적용할 수 있으며 반드시 필요한 것은 아니고 선택적으로 적용할 수 있습니다. 더 많은 필드 옵션이 궁금하다면 아래의 공식 문서를 참고하세요. 
필드 옵션 공식문서 바로 가기 https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-options
필드 옵션	설명	기본값
null	True 일 경우 데이터베이스에 빈 값을 저장할 때
NULL을 사용하게 됩니다.	False
blank	True 일 경우 해당 필드를 비워 둘 수 있게 합니다.	False
default	필드에 기본값을 지정할 때 사용합니다.	
editable	필드의 수정 가능 여부를 설정합니다.	True
help_text	해당 필드를 입력할 때 보여줄 도움말을 설정합니다.	
unique	True 일 경우 중복된 값을 입력할 수 없게 합니다.	False
verbose_name	사람이 인식하기 좋은 별명을 필드에 설정합니다.	
validators	필드의 유효성 검증에 사용할 검증 목록 입니다.	

보면 우리가 배운 것들도 있고 아직 배우지 않은 것들도 있죠? 대부분은 이어지는 레슨들에서 다룰 예정이지만 만약 다루지 않은 부분이 있더라도 걱정하지 마세요. 여러분이 배운 지식을 바탕으로 공식문서를 차근히 읽어보면 나머지 부분들을 사용하는 것도 어렵지 않을거에요.
-----------------------------------------------------------------------------------------------------------------------------

실습과제
100XP
감정 일기 모델(Model) 작성하기

이번에는 앞으로 우리가 감정 일기에서 다룰 '일기'에 대한 데이터 모델을 작성해 봅시다.
아래를 참고해서 models.py에 모델(Model)을 작성해 주세요.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4116&directory=Untitled.png&name=Untitled.png

    models.py에 'Page' 모델 클래스를 정의해주세요.

    Page 클래스에는 아래와 같은 필드가 필요합니다.

    제목(title), 문자열, 길이 제한 100자
    내용(content), 문자열, 길이 제한 없음
    감정 상태(feeling), 문자열, 길이 제한 80자
    감정 점수(score), 정수형
    작성일(dt_created), 날짜

    Page 모델을 문자열로 표시할 때 사용되는 str 메소드를 정의해 주세요

    admin.py에 방금 작성한 Page 모델을 등록해 주세요.

    데이터베이스에 변경 사항을 반영해 주세요.

과제 해설close solution tab

    모델 클래스는 models.Model을 상속 받아서 정의할 수 있습니다.

    # models.py
    from django.db import models

    # Create your models here.
    class Page(models.Model):
        # 모델 필드 정의

    각각의 필드는 문자열은 models.CharField,길이 제한 없는 문자열은 models.TextField, 정수형은 models.IntegerField, 날짜형은 models.DateField로 정의하면 됩니다. 이 중에서 날짜형은 데이터를 생성할 때 자동으로 값이 들어가게는 'auto_now'라는 속성이 있었죠? 이번 감정 일기에서는 직접 날짜를 입력하게 만들 것이기 때문에 적어주지 않겠습니다.

    from django.db import models

    # Create your models here.
    class Page(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        feeling = models.CharField(max_length=80)
        score = models.IntegerField()
        dt_created = models.DateField()

    모델 클래스를 문자열로 표시하기 위해 사용하는 str 함수는 아래와 같이 작성합니다.

    from django.db import models

    # Create your models here.
    class Page(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        feeling = models.CharField(max_length=80)
        score = models.IntegerField()
        dt_created = models.DateField()

        def __str__(self):
            return self.title

    이렇게 작성된 모델을 Django가 제공하는 관리자 페이지에서 사용하기 위해서는 admin.py에 등록해 주어야 합니다. 먼저 작성한 모델을 import 하고 admin.site.register를 이용해 등록합니다.

    from django.contrib import admin
    from .models import Page

    # Register your models here.
    admin.site.register(Page)

    작성한 모델을 데이터 베이스에 반영하기 위해서는 먼저 마이그레이션을 만들고 반영하면 됩니다.

    python manage.py makemigrations
    python manage.py migrate

------------------------------------------------------------------------------------------------------------------------------
    from .models import Page
    from diary.models import Page

다음 두가지 경우 차이가 있나요?

맨 앞에 . 으로 시작하는 경우는 현재 앱 (diary) 디렉토리를 의미하는거 같은데 

맨 앞에 .를 안쓰고 diary.models  라고 하는 것과 어떤 차이가 있나요?

차이는 없습니다.

diary.modes라고 하면 직관적으로 불러오는 모델의 앱이 diary라는 것을 바로 알 수 있는 정도입니다.
-------------------------------------------------------------------------------------------------------------------

데이터 조작하기

프로젝트 루트로 가서 shell을 켜자 -> python3 manage.py shell
모델을 통해 데이터 베이스와 소통하자 -> from posts.models import Post
간단하게 모든 데이터를 불러와보자 -> Post.objects.all() -> 지금은 아무런 데이터가 없다!
첫 데이터를 생성해보자 -> Post.objects.create(title = '첫 포스팅', content = '오늘 새 맥북 프로가 왔어요!')
그런데 지금 데이터를 생성할 때 작성일과 수정일 필드는 입력하지 않았다 -> 우리가 모델 필드를 정의할 때 이 두 값에 대해서는 자동으로 날짜 값이 채워지도록 설정했기 때문에 직접 값을 넣지 않아도 자동으로 채워진다
-> Post.objects.all().values() -> 날짜까지 잘 나온다  

그럼 이제 이 데이터를 수정해보자 Post.objects.get(id=1) 를 하면 우리가 방금 입력한 데이터를 받을 수 있다 Post.objects.get(pk=1) 해도 똑같다 pk 는 primary key(데이터를 구분해준다) 로 지금 primary key는 id이다

post = Post.objects.get(pk=1)
post.title = '맥북 프로와 함께 하는 첫 포스팅 (수정)'
post.save()

그리고 

Post.objects.all().values()

하면 타이틀이 수정되었고 수정일 필드도 수정된것이 보인다 이제 나머지는 관리자 페이지를 이용해서 데이터를 추가해주자

일단 관리자 계정을 만들어야한다 exit() 해서 쉘에서 나와주고 프로젝트 루트에서 python3 manage.py createsuperuser 해서 관리자 계정 만들자
지금 관리자 페이지에 들어가서 로그인해도 Post 모델은 없다 관리자 페이지에서 관리를 하기 위해서는 admin.py 에 먼저 등록을 해줘야한다
posts 앱의 admin.py에 가서 from .models import Post 로 Post 모델을 import 하고  admin.site.register(Post)  관리자 페이지에서 쓸 수 있게 등록해준다
관리자 페이지에 다시가서 새로고침하면 이제 Post 모델이 보인다  두번째 포스트를 아무거나 입력해주자~
-----------------------------------------------------------------------------------------------------------------------------------------

Django Model API

Django에서 Model을 정의하면 ORM을 통해 데이터베이스와 소통할 수 있는 API를 제공합니다. 여기서는 우리가 사용하는 Model API를 정리하고 조금 더 자세히 살펴보겠습니다.
API란?

우리가 앞에서 데이터베이스를 조작할 때 사용했던 아래와 같은 모든 명령어들이 바로 API 입니다.

<model>.objects.all() # 모든 데이터 가져오기
<model>.objects.get() # 조건에 맞는 데이터 1개 가져오기

API란 Application Programming Interface의 약자로 어플리케이션에서 시스템의 기능을 제어할 수 있도록 만든 인터페이스를 말합니다. 쉽게 말하면 어떤 기능을 쉽게 사용할 수 있도록 만든 체계라고 할 수 있는데요, 예를 들어 여러분이 식당에 가면 주문을 받는 직원이 있죠? 우리는 해당 직원을 통해서 먹고 싶은 음식을 주문하고 전달 받아서 맛있게 먹으면 됩니다. 직접 요리사에게 먹고 싶은 음식에 대해 설명하거나 만드는 법을 알려줄 필요가 없죠. 여기서 직원에 해당하는 것이 바로 API 입니다.
Queryset

Queryset은 Django Model의 데이터가 담겨있는 목록으로 파이썬의 리스트와 비슷한 형태를 가지고 있습니다. 우리는 이러한 Queryset을 얻기 위해서 아래와 같은 'objects'를 이용합니다. 이 'objects'는 'Model Manager'라고 하는데 Model과 데이터베이스 간에 연산을 수행하는 역할을 합니다. 이 'objects'를 통해 데이터베이스와 연산해서 얻은 여러 모델 데이터가 담겨 있는 것이 바로 Queryset 인거죠.

<model>.objects.all() # <model>의 모든 데이터 Queryset 가져오기 

Queryset API

자, 어려운 내용은 잠시 내려두고 쉽게 말해서 Queryset은 데이터베이스로 부터 가져온 여러개의 model 데이터 입니다. 우리는 이러한 Queryset을 우리가 원하는 조건에 맞게 만들 수 있으면 되는거죠.

Queryset을 반환 하는 API
API	설명	예시
all()	해당 모델 테이블의 모든 데이터 조회	Post.objects.all()
filter()	특정 조건에 맞는 모든 데이터 조회	Post.objects.filter(content__contains='coke')
exclude()	특정 조건을 제외한 모든 데이터 조회	Post.objects.exclude(title__contains='code')
order_by()	특정 조건으로 정렬된 데이터 조회
(-를 붙이면 오름차순으로 정렬)	Post.objects.order_by('-dt_created')
values()	Queryset에 있는 모든 모델 데이터의 정보를 사전형으로 갖는 리스트 반환	Post.objects.all().values()

하나의 데이터 객체를 반환하는 API
API	설명	예시
get()	조건에 맞는 하나의 데이터 조회	Post.objects.get(id=1)
create()	하나의 데이터를 생성하고 해당 모델 데이터를 반환	Post.objects.create(title='Learning Django', context='Codeit Django')
get_or_create()	조건에 맞는 데이터를 조회하고 해당 데이터가 없다면 새로 생성 후 생성된 모델 데이터를 반환	Post.objects.get_or_create(title='Learning Python', context='It's good’)
latest()	주어진 필드 기준으로 가장 최신의 모델 데이터를 반환	Post.objects.latest('dt_created')
first()	쿼리셋의 가장 첫번째 모델 데이터를 반환, 정렬하지 않은 쿼리셋이라면 pk를 기준으로 정렬 후 반환, 만약 데이터가 없다면 None	Post.objects.order_by('title').first()
last()	연산된 쿼리셋의 가장 가지막 모델 데이터를 반환,
만약 데이터가 없다면 None	Post.objects.order_by('title').last()

그 외 API
API	설명	예시
exists()	연산된 쿼리셋에 데이터가 있다면 True 반환	Post.objects.get(pk=812).exists()
count()	쿼리셋의 데이터 개수를 정수로 반환	Post.objects.all().count()
update()	데이터를 수정할 때 사용
(여러 데이터 또는 여러 필드를 한 번에 수정 가능),
수정된 데이터의 개수를 정수로 반환	Post.objects.filter('dt_created'__yeaer=2021).update(context='codeit')
→ 생성일이 2021년인 모든 포스트 데이터들의 context를 'codeit'으로 바꾸고 변경된 데이터의 개수를 리턴
delete()	데이터를 삭제할 때 사용	post = Post.objects.get(pk=1) post.delete()

필드 조건 옵션 (Field Lookups)

Queryset 연산을 할 때 사용할 수 있는 여러 필드 조건 옵션입니다. 필드명 뒤에 __ 를 쓰고 사용할 옵션 인자를 적어 주면 됩니다. 아래의 조건 옵션 말고도 더 많은 옵션 들이 있습니다. 아래의 공식 문서를 참고하세요.
필드 조건 옵션 공식문서 바로 가기 https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups
lookup	설명	예시
__contains	대소문자를 구분하여 문자열 포함 여부 확인	Post.objects.get(title__contains='Codeit')
__icontains	대소문자를 구분하여 문자열 불포함 여부 확인	Post.objects.get(title__icontains='Codeit')
__in	반복 가능한 객체 안에서의 포함 여부를 확인	Post.objects.filter(id__in=[1, 2, 3])
__gt	초과 여부 확인 (Greater than)	Post.objects.filter(id__gt=4)
__gte	이상 여부 확인 (Greater than or equal to)	Post.objects.get(id__gte=4)
__lt	미만 여부 확인 (Less than)	Post.objects.get(id__lt=4)
__lte	이하 여부 확인 (Less than or equal to)	Post.objects.get(id__lte=4)
__startswith	대소문자를 구분하여 해당 문자열로 시작하는지 여부 확인	Post.objects.filter(title__startswith='code')
__istatswith	대소문자를 구분하여 해당 문자열로 시작하지 않는지 여부 확인	Post.objects.filter(context__istartswith='code')
__endswith	대소문자를 구분하여 해당 문자열로 끝나는지 여부 확인	Post.objects.filter(title__endswith='code')
__iendswith	대소문자를 구분하여 해당 문자열로 끝나지 않는지 여부 확인	Post.objects.filter(title_iendswith='code')
__range	range로 제시하는 범위 내에 포함되는지 확인
(시작과 끝 범위 모두 포함)	import datetime start_date = datetime.date(2021, 1, 1) end_date = datetime.date(2021, 3, 1) Post.objects.filter(dt_created__range=(start_date, end_date))
__isnull	해당 필드가 Null 인지 여부를 확인	Post.objects.filter(context__isnull=True)


Lazy Evaluation (지연연산)

위에서 작성한 Django의 모든 Query 연산은 병합(Chain)이 가능합니다. 예를들어, Post 중에 id가 10 이상이면서 제목에 'codeit'이 들어가는 모든 데이터 중 가장 마지막에 작성된 데이터를 가져오고 싶다고 할게요. 그러면 아래 처럼 작성할 수 있습니다.

Post.objects.filter(id__gte=10, content__contains='codeit').order_by('-dt_created').last()

이렇게 하나의 Query 연산에 여러개를 체인으로 엮어서 구현하는 것이 코드를 짧게 작성하니까 좋다고 생각할 수 있지만 너무 많은 연산을 묶는 것은 지양해야 합니다. 모든 코드는 항상 명확하게 작성해야 합니다. 위처럼 하나의 Query에서 여러 연산을 수행 하도록 하는 것은 가독성을 매우 떨어뜨리므로 복잡한 Query를 한 번에 체인으로 묶는 것은 피하는 것이 좋습니다. 대신 아래처럼 작성하는 거죠. 이전보다 이해하기 쉽고 명확한 코드가 되었습니다.

post_data = Post.objects.filter(id__gte=10, content__contains='codeit')
post_data = post_data.order_by('dt_created')
post_data = post_data.last()

그런데 이렇게 여러 번에 나누어서 작성하면 코드가 훨씬 느려지는 것은 아닐까요? 그에 대한 답은 '그렇지 않다' 입니다. Django의 Query는 기본적으로 지연 연산을 지원합니다. 지연 연산이란 실제로 데이터가 필요하기 전 까지 Query 연산을 수행하지 않고 지연(Lazy)되는 것을 말합니다. 우리가 위에서 처럼 모두 체인으로 묶어서 한 줄로 적는 것과 아래처럼 여러 줄로 나누어 적는 것이 결국 같은 시점에 같은 연산을 수행하게 되는 것이죠. 그래서 우리는 한 줄에 모든 Query 연산과 기능을 작성 하는 것 대신 여러 줄에 얼마든지 Query를 연결해서 작성할 수 있고, 이것은 가독성을 엄청나게 크게 향상시키고 유지보수를 편리하게 해줍니다.
----------------------------------------------------------------------------------------------------------------------------------------------------

이제 본격적으로 웹사이트를 만들어보자 일단 포스트 목록 페이지를 만들자 (domain/posts/)
    path('posts/', views.post_list), urls.py 에서 이 부분을 코멘트 해제하자 그리고 views로 가서 post_list를 구현하도록 하자
->
def post_list(request):
    return render(request, 'posts/post_list.html')
    
그리고 보면 우린 아직 post_list 템플릿을 만든적이 없다 
-> 샌드위치 구조로 post_list.html 만들어준다

그리고 html 기본 뼈대를 쓰고 base 템플릿으로 만든 후 post_list 템플릿이 상속받게 한다

base.html

<!DOCTYPE HTML>
<html>
    <head>
        <meta Charset="UTF-8">
        <title>Costory :: 코스토리</title>
    </head>
    <body>
        {% block post_container%}
        {% endblock post_container%}
    </body>
</html>

post_list.html

{% extends './base.html'%}

{% block post_container %}
    <h1>글 목록 페이지에요</h1>
{% endblock post_container %}

자 개발 서버를 켜고 해당 url로 이동하면 잘나온다 이제 데이터를 가져와서 템플릿으로 보내고 템플릿에서는 전달받은 데이터를 화면에 표시해주자
post_list 뷰에 데이터를 가져오는 로직을 추가해주자 일단 views.py 에 모델을 import 하자 -> from .models import Post
그리고 뷰 안에 추가해준다
->
def post_list(request):
    posts = Post.objects.all()
    context = dict()
    context['posts'] = posts
    return render(request, 'posts/post_list.html', context)
    
이제 post_list.html로 가서 뷰로부터 넘겨 받은 데이터를 화면에 표시한다
->
{% extends './base.html'%}

{% block post_container %}
    <h1>글 목록 페이지에요</h1>
    {% for post in posts %}
        {{post.title}} {{post.dt_created}} {{dt.modified}} <br/>
    {% endfor %}
{% endblock post_container %}

개발서버에서 실행해보면 잘 나오기는 한데 조금 지저분하다 -> 테이블을 사용하면 깔끔하게 할 수 있다

{% extends './base.html'%}

{% block post_container %}
    <h1>글 목록 페이지에요</h1>
    <table>
        <tr>
            <td>제목</td>
            <td>작성일</td>
            <td>수정일</td>
        </tr>
        {% for post in posts %}
            <tr>
                <td>{{post.title}}</td>
                <td>{{post.dt_created}}</td>
                <td>{{dt.modified}}</td>
            </tr>
        {% endfor %}
    </table>
{% endblock post_container %}

자 이게 바로 데이터를 가져와서 보여주는 READ 이다
----------------------------------------------------------------------------------------------------------------------------

포스트 상세 페이지 (READ)

상세페이지를 만들거다 자 모든 기능의 시작은 url이다 posts 앱의 urls.py를 가서 path('posts/<int:post_id>/', views.post_detail), 이 줄을 코멘트 해제한다
그리고 views.py에 가서 post_detal 뷰를 구현하자

def post_detail(request, post_id):
    return render(request, 'posts/post_detail.html')

그리고 지금 post_detail 템플릿이 없으니 만들어주자 

{% extends './base.html' %}

{% block post_container %}
{% endblock post_container %}

여기까지 하고 다시 뷰로 가서 로직을 마저 작성하자

def post_detail(request, post_id):
    post = Post.objects.get(id=post_id)
    context = {'post' : post}
    return render(request, 'posts/post_detail.html', context)

이제 전달 받은 데이터를 템플릿에서 잘 보여주기만 하면 된다

{% extends './base.html' %}

{% block post_container %}
<h2>{{post.title}}</h2>
<div>작성일 : {{post.dt_created}}</div>
<hr>
<div>{{post.content}}</div>
<hr>
{% endblock post_container %}

<hr> 코드는 뭔지 내가 알아서 찾아보자 -> 줄이 그어진다

개발 서버 켜서 잘 나오는지 보자 잘 나오면 관리자 페이지로 가서 좀 긴 글을 써보자 
그리고 그 글에 대한 상세피이지로 가보면 분명 관리자페이지에서 포스트를 추가할 때는 line break을 했는데 웹페이지에서는 line break 이 안되있다
이는 우리가 줄을 바꿀 때 엔터를 눌러 줄바꿈을 하면 줄바꿈이 \n이라는 개행문자로 저장되서 그렇다 그런데 html에서는 줄바꿈이 \n이 아니라 br 태그라서 그런거다
이걸 해결하기 위해서는 \n을 br 태그로 바꿔줘야하는데 템플릿 필터를 사용해서 간단하게 바꿀 수 있다 linebreaksbr 필터를 사용하면 된다
-> <div>{{post.content|linebreaksbr}}</div>
자 이제 다시 새로고침 해보면 줄바꿈해서 잘나온다
--------------------------------------------------------------------------------------------------------------------------------------

사이트 연결하기 

목록 페이지와 상세 페이지를 연결하자 목록 페이지의 제목을 누르면 상세페이지로 가게 하자 -> 제목에 a 태그를 넣어준다             
<td>{{post.title}}</td> -> <td><a href="/posts/{{post.id}}">{{post.title}}</a></td>

그리고 상세페이지에 목록페이지로 다시가는 기능도 만들자 ->  <a href="/posts/">돌아가기</a>  추가

그리고 하나만 더, URL의 Name 속성에 대해 배워보자 name 속성은 각각의 URL 자리에 이름을 붙여주는건데 먼저 post_list.html을 보자
<td><a href="/posts/{{post.id}}">{{post.title}}</a></td> 이 라인을 보면 각각의 포스트로 이동하는 a 태그의 URL들의 앞부분이 /posts/ 이렇게 되어있다
이렇게 데이터가 직접 코드에 들어가 있는것을 하드코딩이라고 하는데 만약에 우리가 urls.py 에서 여기 이 부분  path('posts/<int:post_id>/', views.post_detail),  의 posts 을 blogs 라고 바꾼다고 가정하면 
a 태그 안의 posts도 blogs 로 하나하나 직접 바꿔줘야한다 이렇게 하면 유지보수가 힘들기 때문에 이렇게 하드코딩하지 않으려면 일단 각각의 URL 자리를 대표할 이름이 필요하다 이것이 바로 URL의 name 속성이다

자 posts 앱의 urls.py로 가자

urlpatterns = [
    # path('', views.index),
    path('posts/', views.post_list),
    # path('posts/new', views.post_create),
    path('posts/<int:post_id>/', views.post_detail),
    # path('posts/<int:post_id>/edit', views.post_update),
    # path('posts/<int:post_id>/delete', views.post_delete),
]

이 코드를 다음과 같이 바꿔주자 

urlpatterns = [
    # path('', views.index),
    path('posts/', views.post_list, name="post-list"),
    # path('posts/new', views.post_create),
    path('posts/<int:post_id>/', views.post_detail, name="post-detail"),
    # path('posts/<int:post_id>/edit', views.post_update),
    # path('posts/<int:post_id>/delete', views.post_delete),
]

뒷 부분에 name="URL이름"  해서  URL의 이름을 정의했다 이렇게 네이밍된 URL은 템플릿 태그 URL을 이용해서 쓸 수 있다 우선 post_detail 템플릿으로 가보자

<a href="/posts/">돌아가기</a> 이 부분을 <a href={% url 'post-list' %}>돌아가기</a>  이렇게 바꿔준다

그리고 post_list 템플릿으로 가서 

<td><a href="/posts/{{post.id}}">{{post.title}}</a></td>  이 부분을 <td><a href= {% url 'post-detail' post.id %}>{{post.title}}</a></td>  이렇게 바꿔준다
'post-detail' 뒤에 필요한 인자로 post.id 를 넣어주는것이다
 -----------------------------------------------------------------------------------------------------------

실습과제
감정 일기 상세페이지

이번에는 각각의 감정 일기를 클릭 했을 때 보이는 상세 페이지를 구현해 보도록 하겠습니다. 아래를 참고해서 페이지를 작성해 주세요.

    urls.py에서 상세 페이지에 해당하는 URL 패턴을 주석 해제해 주세요.

    page_detail 뷰를 작성해 주세요.
        뷰 이름은 'page_detail'로 합니다.
        objects.get()을 이용해서 하나의 Page 데이터를 조회해 주세요.
        page_detatil 뷰는 'page_detail.html' 템플릿을 랜더링해서 결과로 돌려줍니다.
        조회한 Page 데이터를 'object'라는 키워드로 page_detail 템플릿에 전달합니다.

    아래를 복사하여 page_detail.html을 작성해 주세요.

    <!-- page_detail.html -->
    <div class="notetext">
        <div class="text-box">
            <h2><!-- 제목--></h2>
            <div class="state">
                <p>감정 상태</p>
                <span><!-- 감정 상태 --></span>
            </div>
            <div class="score">
                <p>감정 점수</p>
                <span><!-- 감정 점수 -->점</span>
            </div> 
            <div class="date">
                <span><!-- 작성 날짜 중 '일(day)'--></span>
                <div class="month-year">
                    <p class="month"><!-- 작성 날짜 중 '월(Month)'--></p>
                    <p class="year"><!-- 작성 날짜 중 '년(year)'--></p>
                </div>
            </div>
            <div class="detail"><!-- 일기 내용 --></div>
            <div class="notetext-btn">
                <ul>
                    <li><a href="#">삭제하기</a></li>
                    <li><a href="#">수정하기</a></li>
                </ul>
            </div>
        </div>
    </div>

    날짜 데이터 중 "월"이나 "일"등 특정 데이터만 가져오고 싶을 때는 
    템플릿 변수의 형태를 바꿔주는 템플릿 필터를 이용하면 됩니다.

    dt_created가 '2020년 12월 31일' 이라면,
    dt_created|date:"d"는 일(day)에 해당하는 "31"로 변환됩니다.
    dt_created|date:"M"은 월(Month)에 해당하는 "Dec"로 변환됩니다.
    dt_created|date:"Y"는 년(Year)에 해당하는 "2020"으로 변환됩니다.

    일기 내용은 줄 바꿈이 정상적으로 적용 되도록 템플릿 필터 'linebreaksbr'을 적용해주세요.

    아래를 참고하여 page_list 템플릿에 각각의 Page를 눌렀을 때 상세 글로 이동하도록 작성해 주세요.

    <h2>일기 목록 페이지</h2>

    <ul>
        {% for obj in object_list %}
        <li>
                    <a href="상세 글로 이동할 URL"> <!-- 클릭 시 이동하기 위한 a 태그 -->
                <div class="date">
                    <span>{{obj.dt_created|date:"d"}}</span>
                    <p>{{obj.dt_created|date:"M"}}</p>
                </div>
                <h2>{{obj.title}}</h2>
                <div class="score">
                    <p>감정점수</p>
                    <span>{{obj.score}}점</span>
                </div>
                    </a>
        </li>
        {% endfor %}
    </ul>

    개발 서버를 켜고 /diary/로 이동한 후 각각의 글을 눌러 상세 페이지로 이동하는지 확인해 주세요.

과제 해설close solution tab

    먼저 urls.py로 가서 상세 페이지에 대한 주석을 해제합니다.

    # urls.py

    from django.urls import path
    from . import views

    urlpatterns = [
        path('diary/', views.page_list),
        # path('diafy/info/', views.info),
        # path('diary/write/', views.page_create),
        path('diary/page/<int:page_id>/', views.page_detail),
        # path('diary/page/<int:page_id>/edit/', views.page_update),
        # path('diary/page/<int:page_id>/delete/', views.page_delete),
    ]

    page_detail 뷰를 정의하는데, 이때 urls에서 넘겨주는 page_id를 파라미터로 받습니다. 그리고 이 page_id를 이용해서 해당 Page 데이터를 조회하고 템플릿으로 전달 합니다.

    # views.py

    def page_detail(request, page_id):
        object = Page.objects.get(id=page_id)
        return render(request, 'diary/page_detail.html', {'object': object})

    diary/templates/diary/page_detail.html 을 작성합니다. 뷰에서 넘겨준 데이터를 이용해서 템플릿 변수로 각각 데이터가 표시될 부분을 작성하면 됩니다.

    <!-- page_detail.html -->

    <div class="notetext">
        <div class="text-box">
            <h2>{{object.title}}</h2>
            <div class="state">
                <p>감정 상태</p>
                <span>{{object.feeling}}</span>
            </div>
            <div class="score">
                <p>감정 점수</p>
                <span>{{object.score}}점</span>
            </div> 
            <div class="date">
                <span>{{object.dt_created|date:"d"}}</span>
                <div class="month-year">
                    <p class="month">{{object.dt_created|date:"M"}}</p>
                    <p class="year">{{object.dt_created|date:"Y"}}</p>
                </div>
            </div>
            <div class="detail">{{object.content}}</div>
            <div class="notetext-btn">
                <ul>
                    <li><a href="#">삭제하기</a></li>
                    <li><a href="#">수정하기</a></li>
                </ul>
            </div>
        </div>
    </div>

    일기 내용이 표시되는 {{ object.content }}에는 줄 바꿈을 
     태그로 바꿔주는 linebreaksbr 템플릿 필터를 적용합니다.

    <div class="notetext">
        ...
            <div class="detail">{{object.content|linebreaksbr}}</div>
        ...
    </div>

    page_list 템플릿으로 가서 이제 각각의 일기를 눌렀을 때 상세 글로 이동하도록 작성합니다. <a> 태그를 이용하면 됩니다. 우리는 하나의 글 전체를 클릭할 수 있는 링크로 만들어 주겠습니다. 클릭했을 때 이동할 URL은 기존의 각 데이터의 id를 포함 해야 합니다. 앞에서 urls.py에 상세 글로 가는 url 패턴을 /diary/page/<int:page_id> 형식으로 작성했기 때문입니다.

    조금 더 설명을 하자면 page_detail 뷰에서 object_list로 모든 데이터를 넘겨 주었고, 우리는 object_list에서 하나씩 Page 데이터를 꺼내서 반복을 하고 있으므로 이 반복 인자인 obj를 이용하면 하나의 Page 데이터에 대한 id 값에 접근할 수 있는거죠.

    <!-- page_list.html -->

    <h2>일기 목록 페이지</h2>

    <ul>
        {% for obj in object_list %}
        <li>
            <a href="/diary/page/{{obj.id}}">
                <div class="date">
                    <span>{{obj.dt_created|date:"d"}}</span>
                    <p>{{obj.dt_created|date:"M"}}</p>
                </div>
                <h2>{{obj.title}}</h2>
                <div class="score">
                    <p>감정점수</p>
                    <span>{{obj.score}}점</span>
                </div>
            </a>
        </li>
        {% endfor %}
    </ul>

    개발 서버를 켜고 /diary/로 이동한 후 각각의 일기 글을 눌러서 상세 보기로 잘 이동하는지 확인합니다.

-------------------------------------------------------------------------------------------------------------------------------------
실습과제
감정 일기 URL 연결하기

지금 page_list 템플릿을 보면 템플릿에 URL이 문자열 형태로 하드코딩 되어있습니다. 이렇게 되면 추후 URL이 변경되었을 때 각 URL이 들어있는 모든 부분을 일일히 찾아서 변경해 주어야 합니다. 모든 소스 코드를 보지 않고도 URL을 관리할 수 있도록 url-name과 url 템플릿 태그를 사용해서 개선해 주세요.

    아래를 참고해서 urls.py의 모든 url 패턴에 name을 작성해 주세요. 주석 처리되어 있는 url은 name을 작성 후 다시 주석으로 변경해 주세요.

    일기 목록 페이지 -> 'page-list'
    감정 일기 소개 페이지 -> 'info'
    새 일기 작성 페이지 -> 'page-create'
    상세 일기 보기 페이지-> 'page-detail'
    일기 수정 페이지 -> 'page-update'
    일기 삭제 페이지 -> 'page-delete'

    page_list 템플릿에 하드코딩 된 url을 url 템플릿 태그와 작성한 url-name을 이용해서 수정해 주세요.

과제 해설close solution tab

    urls.py로 가서 모든 url에 name을 지정해 줍니다.

    from django.urls import path
    from . import views

    urlpatterns = [
        path('diary/', views.page_list, name='page-list'),
        # path('diary/info/', views.info, name='info'),
        # path('diary/write/', views.page_create, name='page-create'),
        path('diary/page/<int:page_id>/', views.page_detail, name='page-detail'),
        # path('diary/page/<int:page_id>/edit/', views.page_update, name='page-update'),
        # path('diary/page/<int:page_id>/delete/', views.page_delete, name='page-delete'),
    ]

    page_list 템플릿으로 가서 하드코딩 되어있는 형태 대신 url 템플릿 태그를 이용하도록 수정합니다. 이때 상세보기 페이지는 id값이 url에 필요하므로 함께 넘겨줄 수 있습니다.

    <h2>일기 목록 페이지</h2>

    <ul>
        {% for obj in object_list %}
        <li>
            <a href="{% url 'page-detail' obj.id %}">
                ...
        {% endfor %}
    </ul>

------------------------------------------------------------------------------------------------------------------------
수업 자료

    Django가 적용되지 않은 정적인 디자인 템플릿입니다. 다운로드해서 직접 확인해보세요!
    design.zip 다운로드

    실행기가 아닌 로컬에서 작업하는 분들을 위한 Costory 템플릿으로 기존의 정적인 디자인 템플릿에 Django 문법을 살짝 적용해서 기본적인 틀을 잡아둔 상태입니다. 다운로드해서 각각의 html 파일은 'templates'디렉토리에 넣고 static 디렉토리는 diary 앱 디렉토리 안에 넣은후 강의를 따라와주세요.
    costory_template.zip 다운로드


디자인 입히기
이건 장고 수업이기 때문에 우리는 이미 만들어논 html과 css 디자인을 쓰자 우리가 지금까지 배운 내용들이 어떤식으로 녹아들어가는지 보자

사실 디자이 템플릿은 무료 디자인 템플릿부터 유료 디자인 템플릿까지 인터넷에 보면 많이 찾아볼 수 있다 중요한건 그 템플릿을 가져와서 장고에 넣는거다 지금 잘 배워놔서
다양한 템플릿을 우리의 웹사이트에 적용할 수 있도록 하자 자 먼저 장고 문법을 적용하지 않은 일반적인 템플릿 디자인 파일을 보자 design.zip을 열고 index.html 을 보자
코스토리 템플릿이 나온다 글들을 눌러보면 상세페이지로 가는데 사실 이 코드들은 하드코딩 되어있다 이 디자인을 가져와서 우리 프로젝트에 적용시켜볼거다 이 디자인폴더를 costory 디렉토리에 넣어서 VSCode를 통해 쉽게 보자
index 부터 detail delete blank posting 템플릿들을 한번 읽어봐라 이 다섯개 템플릿의 head 태그 부분의 구조가 반복되고 있다 또 body 태그 안의 
   <div id="warp">
        <div id="nav">
이 부분도 템플릿들에서 반복되고 있다 또한 이미지 경로나 css 경로들이 하드코딩 되어있다 자 이러한 파일들을 가져온 다음 공통부분들은 base.html에 넣어준 다음 상속받는 방식으로 코딩을 해보자
템플릿마다 변경이 필요한 부분을 블록 처리를 해서 구현하고 이미지나 css같은 정적 파일도 장고 구조 바꿔주자 static 태그를 이용해 처리해보자 또 하드코딩 한 부분들은 데이터베이스에서 데이터를 가져와서 보여주도록 한다
자 이제 코드를 작성하면서 디자인 폴더에 있는 템플릿을 우리 장고 프로젝트에 넣어보자

먼저 수업에서 템플릿 디렉토리 안에 보면 base.html, post_list.html, post_detail.html 이 세개의 파일들은 수업에서 제공하는 코드로 업데이트 해놨다

base.html을 보면

{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <title>코스토리</title>
    <meta charset="UTF-8">
    {% block css %}
    {% endblock css %}
    <link rel="stylesheet" type="text/css"
    href="https://fonts.googleapis.com/earlyaccess/nanummyeongjo.css">
</head>
<body>
   <div id="warp">
        <div id="header">
            <div id="nav">
                <div class="logo">
                    <a href="[A]"><img src="{% static 'posts/images/logo.png' %}"></a>
                </div>
            </div>
            {% block post_header %}
            {% endblock post_header %}
        </div>
        {% block logo_text %}
        {% endblock logo_text %}
        <div id="content">
            <div class="container">
                {% block content %}
                {% endblock content %}
            </div>
        </div>
        <div id="footer">
            <div class="footer">
                <p>Costory</p>
            </div>
        </div>
    </div>
</body>
</html>

공통되는 부분들은 미리 작성해놨고 변경되는 부분을 블락처리 해놓았다 4개의 블락이 있는데 css 블록은 템플릿마다 다른 스타일을 적용해주기 위해서다
{% block post_header %}
{% endblock post_header %}
이 블락은 이 포스트 상세 페이지 위에서 제목을 넣어주기 위해 만들었다
{% block logo_text %}
{% endblock logo_text %}
로고를 넣어주기 위한 블록이고
{% block content %}
{% endblock content %}
이것은 내용을 넣어주기 위한 블록이다

<a href="[A]"><img src="{% static 'posts/images/logo.png' %}"></a>
이 부분을 보자 로고를 누르면 post_list 템플릿 (donamin/posts)가 나오게 구현하는데 이 부분을 하드코딩하지 말고 템플릿 태그로 구현하자
-><a href="{% url 'post-list' %}">

자 그럼 이 base 템플릿을 상속해서 post_detail 과 post_list 템플릿을 적어보자
먼저 post_list 템플릿으로 가자

{% block css %}
    <link rel="stylesheet" href="./css/post_list.css">
{% endblock css %}

{% block logo_text %}
    <div id="header">
        <div class="container">
            <h1><img src="{% static 'posts/images/headertxt.png' %}"></h1>
        </div>
    </div>
{% endblock logo_text %}


{% block content %}
    <div class="post_container">

    </div>
{% endblock content %}

우리는 content 블록을 작성해보겠다 div 태그 안에다가 글 목록을 넣어주면 된다
이 부분은 디자인 폴더 안의 index 템플릿의 이 부분과 일치한다

                    <div class="post"><a href="./detail.html">         
                        <h2 class="title">청춘의 청춘</h2>
                        <p class="date">2020.11.02 22:00</p>
                        <p class="text">노래하며 생생하며, 듣기만 무한한 맺어, 싶이 오직 풀밭에 아니다. 이상 타오르고 따뜻한 주는 밥을 끓는다. 가치를 오아이스도 청춘의 청춘의 때까지 얼마나 힘차게 약동하다. </p>
                    </a></div>
                    
이렇게 하드코딩된 스타일을 우리는 이전의 post_list 템플릿 코드를 참고하여 다르게 써보자
일단 base.html을 상속해준다 -> {% extends './base.html' %}
그리고 css 파일 즉 정적 파일을 써야하니까 load static 해준다 -> {% load static %}
그 다음     <link rel="stylesheet" href="./css/post_list.css">    이 부분을 바꿔주자
->  <link rel="stylesheet" href="{% static 'posts/css/post_list.css' %}">

드디어 content 블락을 채울건데 
<div class="post"><a href="[A] 개별 포스트로 이동하는 URL">         
    <h2 class="title">[B] 글 목록에서 보여질 제목</h2>
    <p class="date">[C] 글 목록에서 보여질 작성일</p>
    <p class="text">[D] 글 목록에서 보여질 본문 100자</p>
</a></div>

이걸 넣어주고 일단 좀 다듬어보자
->
{% block content %}
    <div class="post_container">
        <div class="post"><a href="[A] 개별 포스트로 이동하는 URL">         
            <h2 class="title">[B] 글 목록에서 보여질 제목</h2>
            <p class="date">[C] 글 목록에서 보여질 작성일</p>
            <p class="text">[D] 글 목록에서 보여질 본문 100자</p>
        </a></div>
    </div>
{% endblock content %}

자 이 게시글 목록 같은 경우엔 views.py에서 
def post_list(request):
    posts = Post.objects.all()
    context = dict()
    context['posts'] = posts
    return render(request, 'posts/post_list.html', context)

여기서 context로 넘겨준 이 포스트 데이터를 for 문을 이용해서 모든 데이터를 반복해주면 된다
->
{% block content %}
    <div class="post_container">
        {% for post in posts %}
            <div class="post"><a href="[A] 개별 포스트로 이동하는 URL">         
                <h2 class="title">[B] 글 목록에서 보여질 제목</h2>
                <p class="date">[C] 글 목록에서 보여질 작성일</p>
                <p class="text">[D] 글 목록에서 보여질 본문 100자</p>
            </a></div>
        {% endfor %}
    </div>
{% endblock content %}

그리고 A 부터 D 까지 다 작성해보자

{% block content %}
    <div class="post_container">
        {% for post in posts %}
            <div class="post"><a href="{% url 'post-detail' post.id %}">         
                <h2 class="title">{{post.title}}</h2>
                <p class="date">{{post.dt_created}}</p>
                <p class="text">{{post.content|slice:"0:100"}}</p>
            </a></div>
        {% endfor %}
    </div>
{% endblock content %}

{{post.content|slice:"0:100"}} 이 부분은 내용을 100자로 끊기 위해 필터를 사용했는데 템플릿 필터 slice의 문법은 파이썬 리스트 슬라이싱과 비슷하다 -> 이렇게 하면 0번 인덱스부터 99번 인덱스를 자른다

자 이제 개발서버 켜고 확인해보자

* 여기 보면 base 템플릿의 post_header 블락은 post_list 템플릿에 구현이 안되있는데 안쓸거면 그냥 구현을 안해놓으면 되는건가보다
-----------------------------------------------------------------------------------------------------------------------------------------

디자인 입히기 2 (상세피이지)

post_detail 템플릿으로 가자 이번에는 블록 지정도 안되있다


{% comment %} <!-- post_detail css --> {% endcomment %}
<link rel="stylesheet" href="./css/post-detail.css">


{% comment %} <!-- post_detail header--> {% endcomment %}
<div class="container">
    <h1 class="title">[A] 글 제목</h1>
    <p class="date">[B] 글 작성일</p>
</div>


{% comment %} <!-- post_detail content--> {% endcomment %}
<div class="content">
    <p class="text">[C] 글 본문</p>
    <p class="date_md">수정일 <span>[D] 최종 수정일</span></p>
</div>
    <div class="btn">
    <div class="btn_list"><a href="./post-list.html">목록으로</a></div>
</div>

({% comment %} 태그는 개발서버 실행할 때 <!-- --> 태그는 에러가 나서 내가 따로 붙여줬다)
