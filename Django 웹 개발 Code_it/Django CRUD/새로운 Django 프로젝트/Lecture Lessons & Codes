CRUD 
데이터를 다룰 때 만드시 필요한 네가지 기능 앞에서는 CRUD를 모델과 관련된 기능 정도로만 소개했지만 CRUD는 데이터베이스를 넘어 웹사이트에서 가장 핵심적인 기능이다
유투브 페이스북등 거의 모든 웹사이트는 이 CRUD 기능이 핵심이다 우리는 글 작성 부터 조회 수정 삭제까지 가능한 블로그를 한번 만들어보자

django-admin startproject costory   -> 새 프로젝트를 만들자
cd costory
code .

초기 설정을 해보자 

settings.py 가서 Time Zone을 보자 TIME_ZONE 은 장고 프로젝트가 동작할 때 기준으로 삼을 시간대를 설정해준다 장고가 기본적으로 설정하는 시간대는 UTC이다
시간 설정을 한국으로 하려면 'Asia/Seoul' 이라고 하면 된다

Time Zone : https://docs.djangoproject.com/en/3.2/topics/i18n/timezones/

그리고 블로그 웹사이트에서 포스트 기능을 다룰 posts라는 앱을 생성한다 VSCode 창 띄워놓고 맨 위에 보면 Terminal 탭이 있다 그 아래 보면 New Terminal이 있는데 이거 누르면
VSCode 창에서 터미널 띄울수 있다!

python3 manage.py startapp posts 

그리고 settings.py의 INSTALLED_APPS애 등록해주자

자 그리고 장고 기본 데이터구조를 데이터베이스에 반영하자 INSTALLED_APPS 에 보면 우리가 생성한 앱 말고도 다양한 기본 앱이 있다 migrate를 하면 이 앱들이 필요한 데이터구조가 생성된다
-> python3 manage.py migrate
->
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, foods, menus, sessions
Running migrations:
  No migrations to apply.

자 이제 개발 서버 켜고 잘 되는지 들어가보자
----------------------------------------------------------------------------------------------------------------------------
URL 구조 만들기

Costory 웹사이트의 URL 구조를 생각해보고 전체 웹 사이트의 틀을 잡아보자 웹 사이트의 기능은 URL을 잘 정의 하는 것에서 시작한다

'' (root) -> 블로그의 홈페이지
/posts ->  전체 포스트 조회 (read)
/posts/<post_id> -> 개별 포스트 조회 (read)
/posts/new -> 새 포스트 작성 (create)
/posts/<post_id>/edit -> 포스트 수정 (update)
/posts/<post_id>/delete -> 포스트 삭제 (delete)

그러면 실재로 URL을 작성해보자

앞으로 사용할 URL 구조 -> 이건 강의 밑에 노트로 적혀있던건데 강의에서 URL구조랑 조금 다른데? 흠 
url	설명
/posts/	블로그의 홈페이지
/posts/<post_id>/	개별 포스트 조회
/posts/new/	포스트 작성
/posts/<post_id>/edit/	포스트 수정
/posts/<post_id>/delete/	포스트 삭제

아무것도 없는 domain/ 으로 들어오면 바로 posts 앱의 url로 연결시키자 프로젝트 앱의 urls.py 를 열고 추가한다 일단 include를 inport 해 주고 
path('', include('posts.urls')), 이렇게 경로를 추가해주면 이제 장고가 localhost:8000 과 localhost:8000 뒤에 붙는 추가적인 url 모두 posts 앱의 urls.py를 보고 처리하게 된다
근데 지금 posts 앱에 urls.py 가 없으니 urls.py 를 만들어주자 그리고 안에다 적어주자

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index),
    path('posts/', views.post_list),
    path('posts/new', views.post_create),
    path('posts/<int:post_id>/', views.post_detail),
    path('posts/<int:post_id>/edit', views.post_update),
    path('posts/<int:post_id>/delete', views.post_delete),
]

그리고 path 들은 지금은 주석처리 해주자 아직 view를 구현 안해서 이렇게 실핼하면 에러가 난다
---------------------------------------------------------------------------------------------------------------
path 인자에서 슬래시 유무
posts/, posts/<int:post_id>/ 등에는 끝에 슬래시를 붙이는데,

posts/new, posts/<int:post_id>/ edit 등은 끝에 슬래시를 안 붙여서 차이점이 뭔지 궁금합니다.

먼저 slash 가 필요한 이유는 https://docs.djangoproject.com/en/2.2/ref/settings/#append-slash 에서 속성값이 True 가 기본이기 때문이에용

그래서 / 가 붙지 않으면 올바르게 url 과 view 등이 매칭되지 않을 수 있습니당.

  

이 이유를 근본적으로 좀 생각해보면 좋을텐데용,

장고 디자인 철학에 의하면 다음과 같이 쓰여 있습니다(https://docs.djangoproject.com/en/2.2/misc/design-philosophies/#definitive-urls)

  

    Technically, foo.com/bar and foo.com/bar/ are two different URLs, and search-engine robots (and some Web traffic-analyzing tools) would treat them as separate pages. Django should make an effort to “normalize” URLs so that search-engine robots don’t get confused.

  

이 trailing slash 에 대해 좀 더 살펴보자면 https://djkeh.github.io/articles/Why-do-we-put-slash-at-the-end-of-URL-kor/ 를 참고해보시면 좋습니당.

결국 이런 차이가 있기 때문에 Djagno 에서는 trailing slash 를 쓰는 걸 기본으로 채택하고 있는거라 생각해용

그런 의미에서 위와 같이 7, 9, 10 번 라인에서도 / 을 끝에 붙이는게 맞다고 생각합니당. 오기가 아닐까 싶어용
--------------------------------------------------------------------------------------------------------------------------------------

Model 만들기

블로그에서 사용할 데이터 구조 즉 모델을 정의하자 posts 앱 -> models.py 
장고에서 모델을 정의할때는 models.Model을 상속받아 정의한다 -> class Post(models.Model) 그리고 아래에 모델 필드를 작성해야한다 필요한 필드는 글의 제목, 내용, 작성일, 마지막 수정일
글의 제목 -> title = models.CharField(max_length=50)
글의 내용 -> content = models.TextField()  -> TextField와 CharField의 다른점은 TextField는 최대 길이의 대한 정의가 필요 없다 내용같은 긴 문자열은 항상 TextField를 쓰고 제목 같은 짧은 문자열은 CharField를 쓰자
작성일 -> dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True) -> DateTimeField는 날짜와 시간을 함께 담을 수 있다 인자로 verbose_add이 있는데 이는 사람이 읽기
좋은 필드명을 지정해준다 즉 지금은 DateTime을 편하게 부르기 위해 dt로 줄였지만 나중에 이 필드를 볼 때 알아보기 편하도록 별명을 지어주는것이다 auto_now_add 는 True로 해준다
수정일 -> dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

* DateTimeField : 날짜 + 시간 형식의 필드로 auto_now와 auto_now_add를 매개변수로 가지고 있다
auto_now가 True가 되면 이 포스트가 마지막으로 저장되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 일반적으로 지금처럼 마지막 수정일을 필드로 가지고자 할 때  사용한다
auto_now_add가 True가 되면 이 포스트가 처음 생성되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 지금처럼 데이터 생성일을 필드로 가지고자 할 때 사용한다

auto_now와 auto_now_add 가 둘 다 True이면 에러가 나는데 생각해보면 생성될 때 한번 날짜와 시간을 정하는것과 수정될 때 마다 매번 날짜와 시간을 다시 저장하는 두개가 공존할 수 는 없지?

그리고 마지막으로 def __str__(self): 함수도 써준다 

->

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=50)
    content = models.TextField()
    dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True)
    dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

    def __str__(self):
        return self.title

이제 마이그레이션을 생성하고 반영하면 된다
python3 manage.py makemigrations
python3 manage.py migrate
----------------------------------------------------------------------------------------------------------------------
이런 식으로 클래스로 모델을 만들어 줄 때

(models.Model) 이것을 상속해준다고 하셨는데...

이 의미가 어떤 것인지 잘 모르겠습니다.

좀 더 부연 설명 해주실 수 있을까요...?

상속은 객체지향 코스에서 배우게 되는데, 사실 django 에서 원하는 기능들을 제대로 구현하기 위해선 많은 선수코스들이 존재할겁니당

그래서 장벽을 낮추고자 최소한으로만 선수과제를 표시하셨다고 생각해용

위에서 models 모듈에 Model 이라는 기본 클래스를 상속받게 되는데,

이렇게 상속받아 Post 와 같은 원하는 기능들이 추가된 클래스를 만들게 됩니당

Model 클래스에는 기본적인 기능들이 구현되어 있고,

이를 상속받은 클래스를 통해 필요한 기능들을 나에 맞게 추가한다고 생각하시면 될거에용
---------------------------------------------------------------------------------------------------------------------

모델 필드(Model Field)

Django는 데이터의 타입에 따라 알맞은 필드(Field)를 사용해서 데이터를 다룹니다. 여기서는 우리가 지금까지 사용했던 몇가지 필드 유형과 필드를 정의할 때 사용할 수 있는 옵션들을 정리해 보도록 하겠습니다.
필드 유형(Field Types)

아래는 모델을 정의할 때 데이터에 따라 사용할 수 있는 필드 유형으로 우리가 사용했던 필드들과 그외 타입이 비슷한 필드들의 목록입니다. 이 밖에도 다양한 형식의 필드가 있습니다. 아래의 공식문서를 참고하세요. 
필드 유형 공식문서 바로 가기 https://docs.djangoproject.com/en/2.2/ref/models/fields/#model-field-types
필드명	설명	개별속성
CharField	최대 길이가 정해진 문자열 필드	max_length (최대 글자수)
TextField	최대 길이가 정해지지 않은 문자열 필드	
EmailField	CharField와 같은 문자열 필드지만
입력된 형식이 이메일 형식 인지를 체크하는 필드	max_length=254 (기본값)
URLField	CharField과 같은 문자열 필드지만
입력된 형식이 URL 형식 인지를 체크하는 필드	max_length=200 (기본값)
BooleanField	True, False 값을 갖는 필드	
IntegerField	정수 형식의 필드	
FloatField	부동 소수점 형식의 필드	
DateField	날짜 형식의 필드	auto_now (수정 될 때 마다 새로운 값으로 갱신)
auto_now_add (생성 될 때 값이 입력 되고 추후 변경하지 않음)
TimeField	시간 형식의 필드	auto_now, auto_now_add
DateTimeField	날짜 시간 형식의 필드	auto_now, auto_now_add
필드 옵션(Field options)

모델 필드를 정의할 때 작성할 수 있는 몇 가지 옵션 항목 입니다. 모든 필드에 대해 적용할 수 있으며 반드시 필요한 것은 아니고 선택적으로 적용할 수 있습니다. 더 많은 필드 옵션이 궁금하다면 아래의 공식 문서를 참고하세요. 
필드 옵션 공식문서 바로 가기 https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-options
필드 옵션	설명	기본값
null	True 일 경우 데이터베이스에 빈 값을 저장할 때
NULL을 사용하게 됩니다.	False
blank	True 일 경우 해당 필드를 비워 둘 수 있게 합니다.	False
default	필드에 기본값을 지정할 때 사용합니다.	
editable	필드의 수정 가능 여부를 설정합니다.	True
help_text	해당 필드를 입력할 때 보여줄 도움말을 설정합니다.	
unique	True 일 경우 중복된 값을 입력할 수 없게 합니다.	False
verbose_name	사람이 인식하기 좋은 별명을 필드에 설정합니다.	
validators	필드의 유효성 검증에 사용할 검증 목록 입니다.	

보면 우리가 배운 것들도 있고 아직 배우지 않은 것들도 있죠? 대부분은 이어지는 레슨들에서 다룰 예정이지만 만약 다루지 않은 부분이 있더라도 걱정하지 마세요. 여러분이 배운 지식을 바탕으로 공식문서를 차근히 읽어보면 나머지 부분들을 사용하는 것도 어렵지 않을거에요.
-----------------------------------------------------------------------------------------------------------------------------

실습과제
100XP
감정 일기 모델(Model) 작성하기

이번에는 앞으로 우리가 감정 일기에서 다룰 '일기'에 대한 데이터 모델을 작성해 봅시다.
아래를 참고해서 models.py에 모델(Model)을 작성해 주세요.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4116&directory=Untitled.png&name=Untitled.png

    models.py에 'Page' 모델 클래스를 정의해주세요.

    Page 클래스에는 아래와 같은 필드가 필요합니다.

    제목(title), 문자열, 길이 제한 100자
    내용(content), 문자열, 길이 제한 없음
    감정 상태(feeling), 문자열, 길이 제한 80자
    감정 점수(score), 정수형
    작성일(dt_created), 날짜

    Page 모델을 문자열로 표시할 때 사용되는 str 메소드를 정의해 주세요

    admin.py에 방금 작성한 Page 모델을 등록해 주세요.

    데이터베이스에 변경 사항을 반영해 주세요.

과제 해설close solution tab

    모델 클래스는 models.Model을 상속 받아서 정의할 수 있습니다.

    # models.py
    from django.db import models

    # Create your models here.
    class Page(models.Model):
        # 모델 필드 정의

    각각의 필드는 문자열은 models.CharField,길이 제한 없는 문자열은 models.TextField, 정수형은 models.IntegerField, 날짜형은 models.DateField로 정의하면 됩니다. 이 중에서 날짜형은 데이터를 생성할 때 자동으로 값이 들어가게는 'auto_now'라는 속성이 있었죠? 이번 감정 일기에서는 직접 날짜를 입력하게 만들 것이기 때문에 적어주지 않겠습니다.

    from django.db import models

    # Create your models here.
    class Page(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        feeling = models.CharField(max_length=80)
        score = models.IntegerField()
        dt_created = models.DateField()

    모델 클래스를 문자열로 표시하기 위해 사용하는 str 함수는 아래와 같이 작성합니다.

    from django.db import models

    # Create your models here.
    class Page(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        feeling = models.CharField(max_length=80)
        score = models.IntegerField()
        dt_created = models.DateField()

        def __str__(self):
            return self.title

    이렇게 작성된 모델을 Django가 제공하는 관리자 페이지에서 사용하기 위해서는 admin.py에 등록해 주어야 합니다. 먼저 작성한 모델을 import 하고 admin.site.register를 이용해 등록합니다.

    from django.contrib import admin
    from .models import Page

    # Register your models here.
    admin.site.register(Page)

    작성한 모델을 데이터 베이스에 반영하기 위해서는 먼저 마이그레이션을 만들고 반영하면 됩니다.

    python manage.py makemigrations
    python manage.py migrate

------------------------------------------------------------------------------------------------------------------------------
    from .models import Page
    from diary.models import Page

다음 두가지 경우 차이가 있나요?

맨 앞에 . 으로 시작하는 경우는 현재 앱 (diary) 디렉토리를 의미하는거 같은데 

맨 앞에 .를 안쓰고 diary.models  라고 하는 것과 어떤 차이가 있나요?

차이는 없습니다.

diary.modes라고 하면 직관적으로 불러오는 모델의 앱이 diary라는 것을 바로 알 수 있는 정도입니다.
-------------------------------------------------------------------------------------------------------------------

데이터 조작하기

프로젝트 루트로 가서 shell을 켜자 -> python3 manage.py shell
모델을 통해 데이터 베이스와 소통하자 -> from posts.models import Post
간단하게 모든 데이터를 불러와보자 -> Post.objects.all() -> 지금은 아무런 데이터가 없다!
첫 데이터를 생성해보자 -> Post.objects.create(title = '첫 포스팅', content = '오늘 새 맥북 프로가 왔어요!')
그런데 지금 데이터를 생성할 때 작성일과 수정일 필드는 입력하지 않았다 -> 우리가 모델 필드를 정의할 때 이 두 값에 대해서는 자동으로 날짜 값이 채워지도록 설정했기 때문에 직접 값을 넣지 않아도 자동으로 채워진다
-> Post.objects.all().values() -> 날짜까지 잘 나온다  

그럼 이제 이 데이터를 수정해보자 Post.objects.get(id=1) 를 하면 우리가 방금 입력한 데이터를 받을 수 있다 Post.objects.get(pk=1) 해도 똑같다 pk 는 primary key(데이터를 구분해준다) 로 지금 primary key는 id이다

post = Post.objects.get(pk=1)
post.title = '맥북 프로와 함께 하는 첫 포스팅 (수정)'
post.save()

그리고 

Post.objects.all().values()

하면 타이틀이 수정되었고 수정일 필드도 수정된것이 보인다 이제 나머지는 관리자 페이지를 이용해서 데이터를 추가해주자

일단 관리자 계정을 만들어야한다 exit() 해서 쉘에서 나와주고 프로젝트 루트에서 python3 manage.py createsuperuser 해서 관리자 계정 만들자
지금 관리자 페이지에 들어가서 로그인해도 Post 모델은 없다 관리자 페이지에서 관리를 하기 위해서는 admin.py 에 먼저 등록을 해줘야한다
posts 앱의 admin.py에 가서 from .models import Post 로 Post 모델을 import 하고  admin.site.register(Post)  관리자 페이지에서 쓸 수 있게 등록해준다
관리자 페이지에 다시가서 새로고침하면 이제 Post 모델이 보인다  두번째 포스트를 아무거나 입력해주자~


