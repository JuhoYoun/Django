CRUD 
데이터를 다룰 때 만드시 필요한 네가지 기능 앞에서는 CRUD를 모델과 관련된 기능 정도로만 소개했지만 CRUD는 데이터베이스를 넘어 웹사이트에서 가장 핵심적인 기능이다
유투브 페이스북등 거의 모든 웹사이트는 이 CRUD 기능이 핵심이다 우리는 글 작성 부터 조회 수정 삭제까지 가능한 블로그를 한번 만들어보자

django-admin startproject costory   -> 새 프로젝트를 만들자
cd costory
code .

초기 설정을 해보자 

settings.py 가서 Time Zone을 보자 TIME_ZONE 은 장고 프로젝트가 동작할 때 기준으로 삼을 시간대를 설정해준다 장고가 기본적으로 설정하는 시간대는 UTC이다
시간 설정을 한국으로 하려면 'Asia/Seoul' 이라고 하면 된다

Time Zone : https://docs.djangoproject.com/en/3.2/topics/i18n/timezones/

그리고 블로그 웹사이트에서 포스트 기능을 다룰 posts라는 앱을 생성한다 VSCode 창 띄워놓고 맨 위에 보면 Terminal 탭이 있다 그 아래 보면 New Terminal이 있는데 이거 누르면
VSCode 창에서 터미널 띄울수 있다!

python3 manage.py startapp posts 

그리고 settings.py의 INSTALLED_APPS애 등록해주자

자 그리고 장고 기본 데이터구조를 데이터베이스에 반영하자 INSTALLED_APPS 에 보면 우리가 생성한 앱 말고도 다양한 기본 앱이 있다 migrate를 하면 이 앱들이 필요한 데이터구조가 생성된다
-> python3 manage.py migrate
->
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, foods, menus, sessions
Running migrations:
  No migrations to apply.

자 이제 개발 서버 켜고 잘 되는지 들어가보자
----------------------------------------------------------------------------------------------------------------------------
URL 구조 만들기

Costory 웹사이트의 URL 구조를 생각해보고 전체 웹 사이트의 틀을 잡아보자 웹 사이트의 기능은 URL을 잘 정의 하는 것에서 시작한다

'' (root) -> 블로그의 홈페이지
/posts ->  전체 포스트 조회 (read)
/posts/<post_id> -> 개별 포스트 조회 (read)
/posts/new -> 새 포스트 작성 (create)
/posts/<post_id>/edit -> 포스트 수정 (update)
/posts/<post_id>/delete -> 포스트 삭제 (delete)

그러면 실재로 URL을 작성해보자

앞으로 사용할 URL 구조 -> 이건 강의 밑에 노트로 적혀있던건데 강의에서 URL구조랑 조금 다른데? 흠 
url	설명
/posts/	블로그의 홈페이지
/posts/<post_id>/	개별 포스트 조회
/posts/new/	포스트 작성
/posts/<post_id>/edit/	포스트 수정
/posts/<post_id>/delete/	포스트 삭제

아무것도 없는 domain/ 으로 들어오면 바로 posts 앱의 url로 연결시키자 프로젝트 앱의 urls.py 를 열고 추가한다 일단 include를 inport 해 주고 
path('', include('posts.urls')), 이렇게 경로를 추가해주면 이제 장고가 localhost:8000 과 localhost:8000 뒤에 붙는 추가적인 url 모두 posts 앱의 urls.py를 보고 처리하게 된다
근데 지금 posts 앱에 urls.py 가 없으니 urls.py 를 만들어주자 그리고 안에다 적어주자

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index),
    path('posts/', views.post_list),
    path('posts/new', views.post_create),
    path('posts/<int:post_id>/', views.post_detail),
    path('posts/<int:post_id>/edit', views.post_update),
    path('posts/<int:post_id>/delete', views.post_delete),
]

그리고 path 들은 지금은 주석처리 해주자 아직 view를 구현 안해서 이렇게 실핼하면 에러가 난다
---------------------------------------------------------------------------------------------------------------
path 인자에서 슬래시 유무
posts/, posts/<int:post_id>/ 등에는 끝에 슬래시를 붙이는데,

posts/new, posts/<int:post_id>/ edit 등은 끝에 슬래시를 안 붙여서 차이점이 뭔지 궁금합니다.

먼저 slash 가 필요한 이유는 https://docs.djangoproject.com/en/2.2/ref/settings/#append-slash 에서 속성값이 True 가 기본이기 때문이에용

그래서 / 가 붙지 않으면 올바르게 url 과 view 등이 매칭되지 않을 수 있습니당.

  

이 이유를 근본적으로 좀 생각해보면 좋을텐데용,

장고 디자인 철학에 의하면 다음과 같이 쓰여 있습니다(https://docs.djangoproject.com/en/2.2/misc/design-philosophies/#definitive-urls)

  

    Technically, foo.com/bar and foo.com/bar/ are two different URLs, and search-engine robots (and some Web traffic-analyzing tools) would treat them as separate pages. Django should make an effort to “normalize” URLs so that search-engine robots don’t get confused.

  

이 trailing slash 에 대해 좀 더 살펴보자면 https://djkeh.github.io/articles/Why-do-we-put-slash-at-the-end-of-URL-kor/ 를 참고해보시면 좋습니당.

결국 이런 차이가 있기 때문에 Djagno 에서는 trailing slash 를 쓰는 걸 기본으로 채택하고 있는거라 생각해용

그런 의미에서 위와 같이 7, 9, 10 번 라인에서도 / 을 끝에 붙이는게 맞다고 생각합니당. 오기가 아닐까 싶어용
--------------------------------------------------------------------------------------------------------------------------------------

Model 만들기

블로그에서 사용할 데이터 구조 즉 모델을 정의하자 posts 앱 -> models.py 
장고에서 모델을 정의할때는 models.Model을 상속받아 정의한다 -> class Post(models.Model) 그리고 아래에 모델 필드를 작성해야한다 필요한 필드는 글의 제목, 내용, 작성일, 마지막 수정일
글의 제목 -> title = models.CharField(max_length=50)
글의 내용 -> content = models.TextField()  -> TextField와 CharField의 다른점은 TextField는 최대 길이의 대한 정의가 필요 없다 내용같은 긴 문자열은 항상 TextField를 쓰고 제목 같은 짧은 문자열은 CharField를 쓰자
작성일 -> dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True) -> DateTimeField는 날짜와 시간을 함께 담을 수 있다 인자로 verbose_add이 있는데 이는 사람이 읽기
좋은 필드명을 지정해준다 즉 지금은 DateTime을 편하게 부르기 위해 dt로 줄였지만 나중에 이 필드를 볼 때 알아보기 편하도록 별명을 지어주는것이다 auto_now_add 는 True로 해준다
수정일 -> dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

* DateTimeField : 날짜 + 시간 형식의 필드로 auto_now와 auto_now_add를 매개변수로 가지고 있다
auto_now가 True가 되면 이 포스트가 마지막으로 저장되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 일반적으로 지금처럼 마지막 수정일을 필드로 가지고자 할 때  사용한다
auto_now_add가 True가 되면 이 포스트가 처음 생성되었을 때의 날짜 혹은 날짜와 시간을 자동적으로 해당 필드에 저장한다 지금처럼 데이터 생성일을 필드로 가지고자 할 때 사용한다

auto_now와 auto_now_add 가 둘 다 True이면 에러가 나는데 생각해보면 생성될 때 한번 날짜와 시간을 정하는것과 수정될 때 마다 매번 날짜와 시간을 다시 저장하는 두개가 공존할 수 는 없지?

그리고 마지막으로 def __str__(self): 함수도 써준다 

->

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=50)
    content = models.TextField()
    dt_created = models.DateTimeField(verbose_name="Date Created", auto_now_add = True)
    dt_modified = models.DateTimeField(verbose_name="Date Modified", auto_now = True)

    def __str__(self):
        return self.title

이제 마이그레이션을 생성하고 반영하면 된다
python3 manage.py makemigrations
python3 manage.py migrate
----------------------------------------------------------------------------------------------------------------------
